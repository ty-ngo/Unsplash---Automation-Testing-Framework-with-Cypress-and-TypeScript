var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/builder.ts
var builder_exports = {};
__export(builder_exports, {
  Ajv: () => DEFAULT_AJV,
  DEFAULT_AJV: () => DEFAULT_AJV,
  SchemaBuilder: () => SchemaBuilder,
  and: () => and,
  any: () => any,
  array: () => array,
  boolean: () => boolean,
  const: () => constant,
  create: () => create,
  enum: () => makeEnum,
  fromJSON: () => fromJSON,
  int: () => integer,
  integer: () => integer,
  intersection: () => and,
  keyof: () => keyof,
  literal: () => constant,
  nativeEnum: () => makeEnum,
  never: () => never,
  new: () => create,
  not: () => not,
  null: () => nil,
  number: () => number,
  object: () => object,
  or: () => or,
  record: () => record,
  string: () => string,
  tuple: () => tuple,
  union: () => or,
  unknown: () => unknown
});
import Ajv from "ajv";
import ajvErrors from "ajv-errors";
import addFormats from "ajv-formats";
var DEFAULT_AJV = ajvErrors(
  addFormats(
    new Ajv({
      allErrors: true,
      useDefaults: true
    })
  )
);
var SchemaBuilder = class {
  constructor(schema, _ajv = DEFAULT_AJV) {
    this._ajv = _ajv;
    this._schema = schema;
    this._shape = schema;
  }
  /**
   * type helper. Do Not Use!
   */
  _input;
  /**
   * type helper. Do Not Use!
   */
  _output;
  _schema;
  _shape;
  _preProcesses;
  _postProcesses;
  /**
   * returns JSON-schema representation
   */
  get schema() {
    return this._schema;
  }
  /**
   * returns JSON-schema representation. same as `schema` does.
   * @satisfies zod API
   */
  get shape() {
    return this._shape;
  }
  /**
   * Set custom JSON-Schema representation.
   * Updates `shape` property too
   */
  set schema(schema) {
    this._schema = schema;
    this._shape = schema;
  }
  /**
   * Set custom JSON-Schema representation.
   * Updates `schema` property too
   * @satisfies zod API
   */
  set shape(schema) {
    this._schema = schema;
    this._shape = schema;
  }
  /** Returns your ajv instance */
  get ajv() {
    return this._ajv;
  }
  /**
   * Set Ajv Instance.
   * @throws `TypeError` if not ajv instance comes
   */
  set ajv(instance) {
    if (!(instance instanceof Ajv)) {
      throw new TypeError(`Cannot set ajv variable for non-ajv instance.`, {
        cause: { type: typeof instance, value: instance }
      });
    }
    this._ajv = instance;
  }
  isNullable = false;
  /**
   * set custom JSON-schema field. Useful if you need to declare something but no api founded for built-in solution.
   *
   * Example: `If-Then-Else` you cannot declare without `custom` method.
   * @example
   * const myObj = s.object({
   *  foo: s.string(),
   *  bar: s.string()
   * }).custom('if', {
   *  "properties": {
   *    "foo": { "const": "bar" }
   *  },
   *  "required": ["foo"]
   *  }).custom('then', { "required": ["bar"] })
   */
  custom(key, value) {
    this.schema[key] = value;
    return this;
  }
  /**
   * Marks your property as nullable (`undefined`)
   *
   * **NOTES**: json-schema not accept `undefined` type. It's just `nullable` as typescript `undefined` type.
   */
  optional() {
    return this.nullable();
  }
  /**
   * Marks your property as nullable (`null`).
   *
   * Updates `type` property for your schema.
   * @example
   * const schemaDef = s.string().nullable()
   * schemaDef.schema // { type: ['string', 'null'], nullable: true }
   */
  nullable() {
    this.isNullable = true;
    this.schema.nullable = true;
    const type = this.schema.type;
    if (Array.isArray(type)) {
      this.schema.type = [.../* @__PURE__ */ new Set([...type, "null"])];
    } else {
      this.schema.type = [.../* @__PURE__ */ new Set([type, "null"])];
    }
    return this;
  }
  preFns = [];
  /**
   * pre process function for incoming result. Transform input **BEFORE** calling `parse`, `safeParse`, `validate` functions
   *
   * **NOTE:** this functions works BEFORE parsing. use it at own risk. (e.g. transform Date object into string)
   * @see {@link SchemaBuilder.parse parse} method
   * @see {@link SchemaBuilder.safeParse safe parse} method 
   * @see {@link SchemaBuilder.validate validate} method
   * @example
   * const myString = s.string().preprocess(v => {
   *   // if date => transform to ISO string
   *   if(v instanceof Date) {
   *     return Date.toISOString()
   *   }
   *  // do nothing if not a date
   *   return v
   * })
   * const res = myString.parse(new Date()) // '2023-09-23T07:10:57.881Z'
   * const res = myString.parse('qwe') // 'qwe'
   * const res = myString.parse({}) // error: not a string
   */
  preprocess(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(`Cannot use not a function for pre processing.`, {
        cause: { type: typeof fn, value: fn }
      });
    }
    this.preFns.push(fn);
    return this;
  }
  postFns = [];
  /**
   * Post process. Use it when you would like to transform result after parsing is happens.
   *
   * **NOTE:** this function override your `input` variable for `safeParse` calling.
   * @see {@link SchemaBuilder.safeParse safeParse method}
   */
  postprocess(fn, schema) {
    if (typeof fn !== "function") {
      throw new TypeError(`Cannot use not a function for pre processing.`, {
        cause: { type: typeof fn, value: fn }
      });
    }
    this.postFns.push({ fn, schema });
    return this;
  }
  refineFns = [];
  /**
   * Set custom validation. Any result exept `undefined` will throws.
   * @param fn function that will be called after `safeParse`. Any result will throws
   * @example
   * import s from 'ajv-ts'
   * // example: object with only 1 "active element"
   * const Schema = s.object({
   * active: s.boolean(),
   * name: s.string()
   * }).array().refine((arr) => {
   *  const subArr = arr.filter(el => el.active === true)
   *  if (subArr.length > 1) throw new Error('Array should contains only 1 "active" element')
   * })
   *
   * Schema.parse([{ active: true, name: 'some 1' }, { active: true, name: 'some 2' }]) // throws Error
   */
  refine(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(
        `Cannot set for not a function for refine. Expect "function", Got: ${typeof fn}`,
        { cause: { fn, type: typeof fn } }
      );
    }
    this.refineFns.push(fn);
    return this;
  }
  /**
   * Meta object. Adds meta information fields in your schema, such as `deprecated`, `description`, `$id`, `title` and more!
   */
  meta(obj) {
    Object.entries(obj).forEach(([key, value]) => {
      this.custom(key, value);
    });
    return this;
  }
  /**
   * Option `default` keywords throws exception during schema compilation when used in:
   *
   * - not in `properties` or `items` subschemas
   * - in schemas inside `anyOf`, `oneOf` and `not` ({@link https://github.com/ajv-validator/ajv/issues/42 #42})
   * - in `if` schema
   * - in schemas generated by user-defined _macro_ keywords
   * This means only `object()` and `array()` buidlers are supported.
   * @see {@link object}
   * @see {@link array}
   * @example
   * import s from 'ajv-ts'
   * const Person = s.object({
   *   age: s.int().default(18)
   * })
   * Person.parse({}) // { age: 18 }
   */
  default(value) {
    this.schema.default = value;
    return this;
  }
  /**
   * Defines custom error message for invalid schema.
   *
   * Set `schema.errorMessage = message` under the hood.
   * @example
   * // number example
   * const numberSchema = s.number().error('Not a number')
   * numberSchema.parse('qwe') // error: Not a number
   */
  error(messageOrOptions) {
    this.schema.errorMessage = messageOrOptions;
    return this;
  }
  /**
   * set `description` for your schema.
   * You can use `meta` method to provide information in more consistant way.
   * @see {@link SchemaBuilder.meta meta} method
   * @satisfies `zod` API
   */
  describe(message) {
    return this.meta({ description: message });
  }
  /**
   * set `$async=true` for your current schema.
   *
   * @see {@link https://ajv.js.org/guide/async-validation.html ajv async validation}
   */
  async() {
    this.schema.$async = true;
    return this;
  }
  /**
   * set `$async=false` for your current schema.
   * @param [remove=false] applies `delete` operator for `schema.$async` property.
   */
  sync(remove = false) {
    this.schema.$async = false;
    if (remove) {
      delete this.schema.$async;
    }
    return this;
  }
  /**
   * Construct Array schema. Same as `s.array(s.number())`
   *
   * @see {@link array}
   */
  array() {
    return array(this);
  }
  /**
   * Same as `s.and()`. Combine current type with another. Logical "AND"
   *
   * Typescript `A & B`
   */
  intersection = this.and;
  /**
   * Same as `s.and()`. Combine current type with another. Logical "AND"
   *
   * Typescript `A & B`
   */
  and(...others) {
    return and(this, ...others);
  }
  /**
   * Same as `s.or()`. Combine current type with another type. Logical "OR"
   *
   * Typescript: `A | B`
   */
  or(...others) {
    return or(this, ...others);
  }
  /**
   * Same as `s.or()`. Combine current type with another type. Logical "OR"
   *
   * Typescript: `A | B`
   */
  union = this.or;
  /**
   * Exclude given subschema.
   *
   * Append `not` keyword for your schema
   *
   * @see {@link not}
   * @see {@link SchemaBuilder.not not method}
   * @example
   * cosnt res = s
   *   .string<'Jerry' | 'Martin'>()
   *   .exclude(s.const('Jerry'))
   *   .schema // {type: "string", not: {const: "Jerry"} }
   * type Res = s.infer<typeof res> // 'Martin'
   */
  exclude(s) {
    this.schema.not = s.schema;
    return this;
  }
  /**
   * Exclude self schema.
   *
   * Wrap your schema with `not` keyword
   *
   * `s.not(s.string())` === `s.string().not()`
   *
   * If you need to append `not` keyword instead of wrap you might need to use {@link SchemaBuilder.exclude `exclude`} method
   *
   * @see {@link not}
   * @see {@link SchemaBuilder.exclude exclude method}
   *
   * @example
   * // not string
   * s
   *   .string()
   *   .not()
   *   .schema //  {not: { type: "string" }},
   */
  not() {
    return not(this);
  }
  _transform(input, arr = []) {
    let output;
    if (Array.isArray(arr) && arr.length > 0) {
      try {
        output = arr.reduce(
          (prevResult, el) => {
            if (!prevResult.success) {
              throw prevResult.error;
            }
            let fnTransform;
            let result = {
              data: input,
              input,
              success: true
            };
            if (typeof el === "function") {
              fnTransform = el(prevResult.data, this);
              result.data = fnTransform;
            } else {
              fnTransform = el.fn(prevResult.data, this);
              result = el.schema.safeParse(fnTransform);
            }
            return result;
          },
          { input, data: input, success: true }
        );
      } catch (e) {
        return {
          success: false,
          error: new Error(e.message, { cause: e }),
          input
        };
      }
      return output;
    }
    output = input;
    return { data: output, input, success: true };
  }
  _safeParseRaw(input) {
    let success = false;
    try {
      const validateFn = this.ajv.compile(this.schema);
      success = validateFn(input);
      if (!success) {
        const firstError = validateFn.errors?.at(0);
        return {
          error: new Error(firstError?.message, {
            cause: validateFn.errors
          }),
          success,
          input
        };
      }
    } catch (e) {
      return {
        error: new Error(e.message, { cause: e }),
        success,
        input
      };
    }
    return {
      input,
      data: input,
      success
    };
  }
  /**
   * Parse you input result. Used `ajv.validate` under the hood
   *
   * It also applies your `postProcess` functions if parsing was successfull
   */
  safeParse(input) {
    let preTransformedResult = this._transform(input, this.preFns);
    preTransformedResult.input = input;
    if (!preTransformedResult.success) {
      return preTransformedResult;
    }
    const parseResult = this._safeParseRaw(preTransformedResult.data);
    parseResult.input = input;
    if (!parseResult.success) {
      return parseResult;
    }
    const postTransformedResult = this._transform(
      parseResult.data,
      this.postFns
    );
    postTransformedResult.input = input;
    if (!postTransformedResult.success) {
      return postTransformedResult;
    }
    if (this.refineFns && Array.isArray(this.refineFns) && this.refineFns.length > 0) {
      for (const refine of this.refineFns) {
        try {
          const res = refine(postTransformedResult.data);
          if (res !== void 0) {
            return {
              success: false,
              error: new Error(`refine error`, {
                cause: {
                  refine: res,
                  debug: {
                    input,
                    preTransformedResult,
                    parseResult,
                    postTransformedResult
                  }
                }
              }),
              input: postTransformedResult.data
            };
          }
        } catch (e) {
          return {
            success: false,
            error: e,
            input: postTransformedResult.data
          };
        }
      }
    }
    return postTransformedResult;
  }
  /**
   * Validate your schema.
   *
   * @returns {boolean} Validity of your schema
   */
  validate(input) {
    const { success } = this.safeParse(input);
    return success;
  }
  /**
   * Parse input for given schema.
   *
   * @returns {Output} parsed output result.
   * @throws `Error` when input not match given schema
   */
  parse(input) {
    const result = this.safeParse(input);
    if (!result.success) {
      throw result.error;
    }
    return result.data;
  }
};
var NumberSchemaBuilder = class extends SchemaBuilder {
  constructor() {
    super({ type: "number" });
  }
  /**
   * change schema type from `any integer number` to `any number`.
   *
   * Set schema `{type: 'number'}`
   *
   * This is default behavior
   */
  number() {
    this.schema.type = "number";
    return this;
  }
  /**
   * The `const` keyword is used to restrict a value to a single value.
   * @example
   * const a = s.number().const(5)
   * a.schema // {type: "number", const: 5}
   * s.infer<typeof a> // 5
   */
  const(value) {
    this.schema.const = value;
    return this;
  }
  /** Set schema `{type: 'integer'}` */
  integer() {
    this.schema.type = "integer";
    return this;
  }
  /**
   * Appends format for your number schema.
   */
  format(type) {
    this.schema.format = type;
    return this;
  }
  /** Getter. Retuns `minimum` or `exclusiveMinimum` depends on your schema definition */
  get minValue() {
    return this.schema.minimum ?? this.schema.exclusiveMinimum;
  }
  /** Getter. Retuns `maximum` or `exclusiveMaximum` depends on your schema definition */
  get maxValue() {
    return this.schema.maximum ?? this.schema.exclusiveMaximum;
  }
  min = this.minimum;
  /**
   * Provides minimum value
   *
   * Set schema `minimum = value` (and add `exclusiveMinimum = true` if needed)
   * @example
   * s.number().min(2, true) // > 2
   * s.number().min(2) // >= 2
   */
  minimum(value, exclusive = false) {
    if (exclusive) {
      this.schema.exclusiveMinimum = value;
    } else {
      this.schema.minimum = value;
    }
    return this;
  }
  step = this.multipleOf;
  /**
   * Numbers can be restricted to a multiple of a given number, using the `multipleOf` keyword.
   * It may be set to any positive number. Same as `step`.
   *
   * **NOTE**: Since JSON schema odes not allow to use `multipleOf` with negative value - we use `Math.abs` to transform negative values into positive
   * @see {@link NumberSchemaBuilder.step step}
   * @example
   * const a = s.number().multipleOf(10)
   *
   * a.parse(10) // ok
   * a.parse(9) // error
   *
   * const b = s.number().multipleOf(-0.1)
   * b.parse(1.1) // ok, step is `0.1`
   * b.parse(1) // error, step is not `0.1`
   */
  multipleOf(value) {
    this.schema.multipleOf = Math.abs(value);
    return this;
  }
  max = this.maximum;
  /**
   * marks you number maximum value
   */
  maximum(value, exclusive = false) {
    if (exclusive) {
      this.schema.exclusiveMaximum = value;
    } else {
      this.schema.maximum = value;
    }
    return this;
  }
  /**
   * Greater than
   *
   * @see {@link NumberSchemaBuilder.maximum}
   * @see {@link NumberSchemaBuilder.gte}
   */
  gt(value) {
    return this.minimum(value, true);
  }
  /**
   * Greater than or equal
   *
   * Range: `[value; Infinity)`
   * @see {@link NumberSchemaBuilder.maximum maximum}
   * @see {@link NumberSchemaBuilder.gt gt}
   */
  gte(value) {
    return this.minimum(value);
  }
  /**
   * Less than
   *
   * Range: `(value; Infinity)`
   * @see {@link NumberSchemaBuilder.minimum minimum}
   * @see {@link NumberSchemaBuilder.lte lte}
   */
  lt(value) {
    return this.max(value, true);
  }
  /**
   * Less than or Equal
   *
   * Range: `[value; Infinity)`
   * @see {@link NumberSchemaBuilder.minimum}
   * @see {@link NumberSchemaBuilder.lt}
   */
  lte(value) {
    return this.max(value);
  }
  /** Any positive number (greater than `0`)
   * Range: `(0; Infinity)`
   */
  positive() {
    return this.gt(0);
  }
  /** Any non negative number (greater than or equal `0`)
   *
   * Range: `[0; Inifnity)`
   */
  nonnegative() {
    return this.gte(0);
  }
  /** Any negative number (less than `0`)
   *
   * Range: `(Inifinity; 0)`
   */
  negative() {
    return this.lt(0);
  }
  /** Any non postive number (less than or equal `0`)
   *
   * Range: `(Inifinity; 0]`
   */
  nonpositive() {
    return this.lte(0);
  }
  /** Marks incoming number between `MAX_SAFE_INTEGER` and `MIN_SAFE_INTEGER` */
  safe() {
    return this.lte(Number.MAX_SAFE_INTEGER).gte(Number.MIN_SAFE_INTEGER);
  }
};
function number() {
  return new NumberSchemaBuilder();
}
function integer() {
  return new NumberSchemaBuilder().integer();
}
var StringSchemaBuilder = class extends SchemaBuilder {
  /** DO not use. This is typescript type */
  _opts;
  /**
   * The `pattern` use regular expressions to express constraints.
   * The regular expression syntax used is from JavaScript ({@link https://www.ecma-international.org/publications-and-standards/standards/ecma-262/ ECMA 262}, specifically).
   * However, that complete syntax is not widely supported, therefore it is recommended that you stick to the subset of that syntax described below.
   *
   * - A single unicode character (other than the special characters below) matches itself.
   * - `.`: Matches any character except line break characters. (Be aware that what constitutes a line break character is somewhat dependent on your platform and language environment, but in practice this rarely matters).
   * - `^`: Matches only at the beginning of the string.
   * - `$`: Matches only at the end of the string.
   * - `(...)`: Group a series of regular expressions into a single regular expression.
   * - `|`: Matches either the regular expression preceding or following the | symbol.
   * - `[abc]`: Matches any of the characters inside the square brackets.
   * - `[a-z]`: Matches the range of characters.
   * - `[^abc]`: Matches any character not listed.
   * - `[^a-z]`: Matches any character outside of the range.
   * - `+`: Matches one or more repetitions of the preceding regular expression.
   * - `*`: Matches zero or more repetitions of the preceding regular expression.
   * - `?`: Matches zero or one repetitions of the preceding regular expression.
   * - `+?`, `*?`, `??`: The *, +, and ? qualifiers are all greedy; they match as much text as possible. Sometimes this behavior isn't desired and you want to match as few characters as possible.
   * - `(?!x)`, `(?=x)`: Negative and positive lookahead.
   * - `{x}`: Match exactly x occurrences of the preceding regular expression.
   * - `{x,y}`: Match at least x and at most y occurrences of the preceding regular expression.
   * - `{x,}`: Match x occurrences or more of the preceding regular expression.
   * - `{x}?`, `{x,y}?`, `{x,}?`: Lazy versions of the above expressions.
   * @example
   * const phoneNumber = s.string().pattern("^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$")
   *
   * phoneNumber.parse("555-1212") // OK
   * phoneNumber.parse("(888)555-1212") // OK
   * phoneNumber.parse("(888)555-1212 ext. 532") // Error
   * phoneNumber.parse("(800)FLOWERS") // Error
   * // typescript custom type
   * const prefixS = s.string().pattern<`S_${string}`>("^S_$")
   * type S = s.infer<typeof prefixS> // `S_${string}`
   * const str1 = prefixS.parse("qwe") // Error
   * const str2 = prefixS.parse("S_Some") // OK
   */
  pattern(pattern) {
    this.schema.pattern = pattern;
    return this;
  }
  constructor() {
    super({ type: "string" });
  }
  const(value) {
    this.schema.const = value;
    return this;
  }
  /**
   * Define minimum string length.
   *
   * Same as `min`
   * @see {@link StringSchemaBuilder.min min}
   */
  minLength(value) {
    this.schema.minLength = value;
    return this;
  }
  /**
   * Define minimum string length.
   *
   * Same as `minLength`
   * @see {@link StringSchemaBuilder.minLength minLength}
   */
  min = this.minLength;
  /**
   * Define maximum string length.
   *
   * Same as `max`
   * @see {@link StringSchemaBuilder.max max}
   */
  maxLength(value) {
    this.schema.maxLength = value;
    return this;
  }
  /**
   * Define maximum string length.
   *
   * Same as `maxLength`
   * @see {@link StringSchemaBuilder.maxLength maxLength}
   */
  max = this.maxLength;
  /**
   * Define exact string length
   *
   * Same as `s.string().min(v).max(v)`
   *
   * @see {@link StringSchemaBuilder.minLength minLength}
   * @see {@link StringSchemaBuilder.maxLength maxLength}
   * @example
   * const exactStr = s.string().length(3)
   * exactStr.parse('qwe') //Ok
   * exactStr.parse('qwer') // Error
   * exactStr.parse('go') // Error
   */
  length(value) {
    return this.maxLength(value).minLength(value);
  }
  /**
   * Define non empty string. Same as `minLength(1)`
   */
  nonEmpty() {
    return this.minLength(1);
  }
  /**
   * A string is valid against this format if it represents a valid e-mail address format.
   *
   * Example: `some@gmail.com`
   */
  email() {
    return this.format("email");
  }
  ipv4() {
    return this.format("ipv4");
  }
  ipv6() {
    return this.format("ipv6");
  }
  /**
   * A Universally Unique Identifier as defined by {@link https://datatracker.ietf.org/doc/html/rfc4122 RFC 4122}.
   *
   * Same as `s.string().format('uuid')`
   *
   * Example: `3e4666bf-d5e5-4aa7-b8ce-cefe41c7568a`
   */
  uuid() {
    return this.format("uuid");
  }
  /**
   * A string is valid against this format if it represents a time in the following format: `hh:mm:ss.sTZD`.
   *
   * Same as `s.string().format('time')`
   *
   * Example: `20:20:39+00:00`
   */
  time() {
    return this.format("time");
  }
  /**
   * A string is valid against this format if it represents a date in the following format: `YYYY-MM-DD`.
   *
   * Same as `s.string().format('date')`
   *
   * Example: `2023-10-10`
   */
  date() {
    return this.format("date");
  }
  /**
   * A string is valid against this format if it represents a date-time in the following format: `YYYY:MM::DDThh:mm:ss.sTZD`.
   *
   * Same as `s.string().format('date-time')`
   *
   * Example: `2023-10-05T05:49:37.757Z`
   */
  dateTime() {
    return this.format("date-time");
  }
  /**
   * A string is valid against this format if it represents a valid regular expression.
   *
   * Same as `s.string().format('regex')`
   */
  regex() {
    return this.format("regex");
  }
  format(formatType) {
    this.schema.format = formatType;
    return this;
  }
  // override parse<
  //   const I extends string,
  //   Matches = I extends S ? true : false,
  //   ValidMinLength = GreaterThanOrEqual<StringLength<I>, Opts['minLength'] extends number ? Opts['minLength'] : number>
  // >(input?: Matches extends true ?
  //   ValidMinLength extends true
  //   ? I
  //   : TRangeGenericError<`Incoming parameter not matches MinLength requirement. Got '${I}'. MinLength: ${Opts['minLength']}`>
  //   : TTypeGenericError<`Incoming type '${I}' not mathes to expected '${S}'`>
  // ): S {
  //   return super.parse(input) as never
  // }
};
function string() {
  return new StringSchemaBuilder();
}
var BooleanSchemaBuilder = class extends SchemaBuilder {
  constructor() {
    super({ type: "boolean" });
  }
};
function boolean() {
  return new BooleanSchemaBuilder();
}
var NullSchemaBuilder = class extends SchemaBuilder {
  constructor() {
    super({ type: "null" });
  }
};
function nil() {
  return new NullSchemaBuilder();
}
var ObjectSchemaBuilder = class _ObjectSchemaBuilder extends SchemaBuilder {
  def = {};
  constructor(def) {
    super({
      type: "object",
      properties: {}
    });
    if (def) {
      Object.entries(def).forEach(([key, d]) => {
        this.schema.properties[key] = d.schema;
      });
      this.def = def;
    }
  }
  /**
   * set `additionalProperties=true` for your JSON-schema.
   *
   * Opposite of `strict`
   * @see {@link ObjectSchemaBuilder.strict strict}
   */
  passthrough() {
    this.schema.additionalProperties = true;
    return this;
  }
  /**
   * Makes all properties partial(not required)
   */
  partial() {
    this.schema.required = [];
    return this;
  }
  /**
   * Makes selected properties partial(not required), rest of them are not changed.
   *
   * Same as for as for `requiredFor('item1').requiredFor('item2')...etc`
   *
   * @example
   * const Test = s.object({
   *  name: s.string(),
   *  email: s.string(),
   * })
   * .required()
   * .partialFor('email')
   *
   * Test.schema === {
   *  type: 'object',
   *  properties: {
   *    "name": {type: 'string'},
   *    "email": {type: 'string'}
   *  }
   *  "required": ['name']
   * }
   */
  partialFor(key) {
    const required = this.schema.required ?? [];
    const findedIndex = required.indexOf(key);
    if (findedIndex !== -1) {
      this.schema.required.splice(findedIndex, 1);
    }
    return this;
  }
  /**
   * The `dependentRequired` keyword conditionally requires that
   * certain properties must be present if a given property is
   * present in an object. For example, suppose we have a schema
   * representing a customer. If you have their credit card number,
   * you also want to ensure you have a billing address.
   * If you don't have their credit card number, a billing address
   * would not be required. We represent this dependency of one property
   * on another using the `dependentRequired` keyword.
   * The value of the `dependentRequired` keyword is an object.
   * Each entry in the object maps from the name of a property, p,
   * to an array of strings listing properties that are required
   * if p is present.
   *
   * In the following example,whenever a `credit_card` property is provided,
   * a `billing_address` property must also be present:
   * @example
   * const Test1 = s.object({
   * name: s.string(),
   * credit_card: s.number(),
   * billing_address: s.string(),
   * }).requiredFor('name').dependentRequired({
   *   credit_card: ['billing_address'],
   * })
   * Test1.schema === {
   *   "type": "object",
   *   "properties": {
   *     "name": { "type": "string" },
   *     "credit_card": { "type": "number" },
   *     "billing_address": { "type": "string" }
   *   },
   *   "required": ["name"],
   *   "dependentRequired": {
   *     "credit_card": ["billing_address"]
   *   }
   * }
   */
  dependentRequired(dependencies) {
    this.schema.dependentRequired = dependencies;
    return this;
  }
  /**
   * Disallow additional properties for object schema `additionalProperties=false`
   *
   * If you would like to define additional properties type - use `additionalProeprties`
   * @see {@link ObjectSchemaBuilder.additionalProperties additionalProperties}
   */
  strict() {
    this.schema.additionalProperties = false;
    return this;
  }
  /**
   * Makes 1 property required, other keys are not required.
   *
   * If some properties is already marked with `requiredFor` - we append new key into `required` JSON schema
   */
  requiredFor(...keys) {
    this.schema.required = [
      .../* @__PURE__ */ new Set([...this.schema.required ?? [], ...keys])
    ];
    return this;
  }
  /**
   * Make **ALL** properties in your object required.
   *
   * If you need to make 1 property required - use {@link ObjectSchemaBuilder.requiredFor}
   */
  required() {
    const allProperties = Object.keys(this.schema.properties);
    this.schema.required = [
      .../* @__PURE__ */ new Set([...this.schema.required ?? [], ...allProperties])
    ];
    return this;
  }
  /**
   * Define schema for additional properties
   *
   * If you need to make `additionalProperties=false` use `strict` method instead
   *
   * @see {@link ObjectSchemaBuilder.strict strict}
   */
  rest(def) {
    this.schema.additionalProperties = def.schema;
    return this;
  }
  /**
   * Merge current object with another object definition
   * @example
   * const a = s.object({num: s.number()})
   * const b = s.object({str: s.string()})
   * const c = a.merge(b)
   * type C = s.infer<typeof c> // {num: number; str: string}
   */
  merge(schema) {
    if (schema.schema.type !== "object") {
      throw new TypeError("Cannot merge not object type with object", {
        cause: {
          incoming: schema.schema,
          given: this.schema
        }
      });
    }
    const a = object();
    a.schema = Object.assign({}, this.schema);
    Object.entries(schema.def).forEach(([key, def]) => {
      a.schema.properties[key] = def.schema;
    });
    a.def = { ...this.def, ...schema.def };
    return a;
  }
  /**
   * Same as `merge`, but not accepts `s.object`.
   * @example
   * const a = s.object({num: s.number()})
   * const c = a.extend({str: s.string()})
   * type C = s.infer<typeof c> // {num: number; str: string}
   */
  extend(def) {
    const a = object();
    a.schema = Object.assign({}, this.schema);
    Object.entries(def).forEach(([key, def2]) => {
      a.schema.properties[key] = def2.schema;
    });
    a.def = { ...this.def, ...def };
    return a;
  }
  /**
   * Mark object as `readOnly`. It mostly decoration for typescript.
   * 
   * Set `schema.readOnly=true`.
   * @see {@link https://json-schema.org/draft-07/json-schema-validation#rfc.section.10.3 JSON-schema - readOnly keyword}
   */
  readonly() {
    this.schema.readOnly = true;
    return this;
  }
  /**
   * Inspired by TypeScript's built-in `Pick` and `Omit` utility types,
   * all object schemas have `.pick` and `.omit` methods that return a modified version.
   * Consider this Recipe schema:
   * @example
   * const Recipe = z.object({
   * id: z.string(),
   * name: z.string(),
   * ingredients: z.array(z.string()),
   * });
   * const JustTheNameAndId = Recipe.pick('name', 'id');
   * type JustTheName = s.infer<typeof JustTheNameAndId>;
   * // => { name: string, id: string }
   */
  pick(...keys) {
    const picked = {};
    Object.entries(this.def).forEach(([k, def]) => {
      const finded = keys.find((key) => key === k);
      if (finded) {
        picked[k] = def;
      }
    });
    return new _ObjectSchemaBuilder(picked);
  }
  /**
   * Inspired by TypeScript's built-in `Pick` and `Omit` utility types,
   * all object schemas have `.pick` and `.omit` methods that return a modified version.
   * Consider this Recipe schema:
   * @example
   * const Recipe = s.object({
   * id: s.string(),
   * name: s.string(),
   * ingredients: s.array(s.string()),
   * });
   * const JustTheName = Recipe.omit('name');
   * type JustTheName = s.infer<typeof JustTheName>;
   * // => { id: string; ingredients: string[] }
   */
  omit(...keys) {
    keys.forEach((k) => {
      delete this.def[k];
    });
    return new _ObjectSchemaBuilder(this.def);
  }
  /**
   * Use `.keyof` to create a `EnumSchema` from the keys of an object schema.
   * @example
   * const Dog = z.object({
   *   name: z.string(),
   *   age: z.number(),
   * });
   * const keySchema = Dog.keyof();
   * keySchema; // Enum<["name", "age"]>
   */
  keyof() {
    return makeEnum(
      Object.keys(this.def)
    );
  }
};
function object(def) {
  return new ObjectSchemaBuilder(def);
}
var RecordSchemaBuilder = class extends SchemaBuilder {
  constructor(def) {
    super({
      type: "object",
      additionalProperties: {}
    });
    if (def) {
      this.schema.additionalProperties = def.schema;
    }
  }
};
function record(valueDef) {
  return new RecordSchemaBuilder(valueDef);
}
var ArraySchemaBuilder = class extends SchemaBuilder {
  constructor(definition) {
    super({ type: "array", items: definition?.schema ?? {}, minItems: 0 });
  }
  /**
   * Make your array `readonly`.
   *
   * Set in JSON schema `unevaluatedItems=false`.
   */
  readonly() {
    this.schema.unevaluatedItems = false;
    return this;
  }
  /**
   * set `prefixItems` in your schema.
   *
   * For better DX - we mark main element schema as `element`.
   */
  prefix(...definitions) {
    this.schema.prefixItems = definitions.map((def) => def.schema);
    return this;
  }
  /**
   * Append subschema for current array schema.
   *
   * If your schema contains 1 element - this method will transform to array.
   *
   * **NOTE:** if your schema defined with `items: false` - `boolean` value will be replaced to incoming schema.
   *
   * @example
   * import s from 'ajv-ts'
   * const arr = s
   *   .array(s.string()) // schema = { type: 'array', items: {type: 'string'} }
   *   .addItems(s.number(), s.boolean())
   * arr.schema // {type: 'array', items: [{type: 'string'}, {type: 'number'}, {type: 'boolean'}] }
   */
  addItems(...s) {
    if (Array.isArray(this.schema.items)) {
      this.schema.items.push(...s.map((el) => el.schema));
    } else if (typeof this.schema.items === "object") {
      const prev = this.schema.items;
      const isEmptyObject = Object.keys(prev).length === 0 && prev.constructor === Object;
      if (isEmptyObject) {
        this.schema.items = s.map((el) => el.schema);
      } else {
        this.schema.items = [prev, ...s.map((el) => el.schema)];
      }
    } else {
      this.schema.items = s.map((el) => el.schema);
    }
    return this;
  }
  max = this.maxLength;
  /**
   * Must contain less items or equal than declared
   * @see {@link ArraySchemaBuilder.length length}
   * @see {@link ArraySchemaBuilder.minLength minLength}
   * @example
   * const arr = s.array(s.number()).maxLength(3)
   * arr.parse([1, 2, 3]) // OK
   * arr.parse([1]) // OK
   * arr.parse([1, 2, 3, 4]) // Error
   */
  maxLength(value) {
    this.schema.maxItems = value;
    return this;
  }
  /**
  * Must contain more items or equal than declared
  *
  * @see {@link ArraySchemaBuilder.length length}
  * @see {@link ArraySchemaBuilder.maxLength maxLength}
  * @example
  * const arr = s.array(s.number()).minLength(3)
  * arr.parse([1, 2, 3]) // OK
  * arr.parse([1]) // Error
  * arr.parse([1, 2, 3, 4]) // OK
  */
  minLength(value) {
    if (value < 0) {
      throw new TypeError(
        `Only Positive and non floating numbers are supported.`
      );
    }
    this.schema.minItems = value;
    return this;
  }
  min = this.minLength;
  /**
   * Returns schema builder of the element.
   *
   * If element is an array - returns `ArraySchemaBuilder` instance
   *
   * @example
   * import s from 'ajv-ts'
   * const strArr = s.array(s.string())
   * const str = strArr.element // isntance of StringSchemaBuilder
   * s.parse('qwe') // ok, string schema
   * s.schema // {type: 'string'}
   */
  get element() {
    const elementSchema = this.schema.items;
    if (Array.isArray(elementSchema)) {
      const builder = array();
      builder.schema = { type: "array", items: elementSchema };
      return builder;
    } else {
      const builder = any();
      builder.schema = elementSchema;
      return builder;
    }
  }
  /**
   * Must contain array length exactly. Same as `minLength(v).maxLength(v)`
   * @see {@link ArraySchemaBuilder.maxLength}
   * @see {@link ArraySchemaBuilder.minLength}
   * @example
   * const arr = s.array(s.number()).length(5)
   * arr.parse([1, 2, 3, 4, 5]) // OK
   * arr.parse([1, 2, 3, 4, 5, 6]) // Error
   * arr.parse([1, 2, 3, 4]) // Error
   */
  length(value) {
    return this.minLength(value).maxLength(value);
  }
  /**
   * same as `s.array().minLength(1)`
   * @see {@link ArraySchemaBuilder.minLength}
   */
  nonEmpty() {
    return this.minLength(1);
  }
  /**
   * Set the `uniqueItems` keyword to `true`.
   * @example
   * const items = s.array(s.number()).unique()
   *
   * items.parse([1, 2, 3, 4, 5]) // OK
   * items.parse([1, 2, 3, 3, 3]) // Error: items are not unique
   */
  unique() {
    this.schema.uniqueItems = true;
    return this;
  }
  /**
   * `contains` schema only needs to validate against one or more items in the array.
   *
   * JSON Schema: `{type: 'array', contains: <json-schema>}`
   * @example
   * const arr = s.array().contains(s.number())
   * arr.validate([]) // false, no numbers here
   * arr.validate([true, 1, 'str']) // true
   */
  contains(containItem) {
    this.schema.contains = containItem.schema;
    return this;
  }
  /**
   * ## draft 2019-09
   * `minContains` and `maxContains` can be used with contains to further specify how many times a schema matches a
   * `contains` constraint. These keywords can be any non-negative number including zero.
   * @example
   * const schema = s.array(s.string()).contains(s.number()).minContains(3)
   * schema.parse(['qwe', 1,2,3]) // OK
   * schema.parse(['qwe', 1,2]) // Error, expect at least 3 numerics
   */
  minContains(value) {
    this.schema.minContains = value;
    return this;
  }
  /**
   * ## draft 2019-09
   * `minContains` and `maxContains` can be used with contains to further specify how many times a schema matches a
   * `contains` constraint. These keywords can be any non-negative number including zero.
   * @example
   * const schema = s.array(s.string()).contains(s.number()).maxContains(3)
   * schema.parse(['qwe', 1,2,3]) // OK
   * schema.parse(['qwe', 1,2,3, 4]) // Error, expect max 3 numbers
   */
  maxContains(value) {
    this.schema.maxContains = value;
    return this;
  }
};
function array(definition) {
  return new ArraySchemaBuilder(definition);
}
var TupleSchemaBuilder = class extends SchemaBuilder {
  constructor(...defs) {
    super({
      type: "array",
      prefixItems: defs.map((def) => def.schema),
      additionalItems: false
    });
  }
  /** set `unevaluatedItems` to `false`. That means that all properties should be evaluated */
  required() {
    this.schema.unevaluatedItems = false;
    return this;
  }
};
function tuple(defs) {
  return new TupleSchemaBuilder(...defs);
}
var EnumSchemaBuilder = class extends SchemaBuilder {
  _enum = {};
  options = [];
  constructor(values) {
    super({ enum: values });
    values.forEach((v) => {
      this._enum[v] = v;
    });
    this.options = values;
  }
  /**
   * returns enum as object representation
   */
  get enum() {
    return this._enum;
  }
};
var NativeEnumSchemaBuilder = class extends SchemaBuilder {
  constructor(enumValues) {
    super({ enum: Object.values(enumValues) });
    this.enumValues = enumValues;
  }
  get enum() {
    return this.enumValues;
  }
  get options() {
    return Object.values(this.enumValues);
  }
};
function makeEnum(tupleOrEnum) {
  if (typeof tupleOrEnum === "object" && tupleOrEnum !== null && !Array.isArray(tupleOrEnum)) {
    return new NativeEnumSchemaBuilder(tupleOrEnum);
  } else if (Array.isArray(tupleOrEnum)) {
    return new EnumSchemaBuilder(tupleOrEnum);
  }
  throw new Error(`Cannot handle non tuple or non enum type.`, {
    cause: { type: typeof tupleOrEnum, value: tupleOrEnum }
  });
}
var ConstantSchemaBuilder = class extends SchemaBuilder {
  constructor(value) {
    super({ const: value });
    this.value = value;
  }
};
function constant(value) {
  return new ConstantSchemaBuilder(value);
}
var UnionSchemaBuilder = class extends SchemaBuilder {
  constructor(...schemas) {
    super({
      anyOf: schemas.map((s) => s.schema)
    });
  }
};
function or(...defs) {
  return new UnionSchemaBuilder(...defs);
}
var IntersectionSchemaBuilder = class extends SchemaBuilder {
  constructor(...schemas) {
    super({
      allOf: schemas.map((s) => s.schema)
    });
  }
};
function and(...defs) {
  return new IntersectionSchemaBuilder(...defs);
}
function keyof(obj) {
  if (!obj.schema.properties) {
    throw new Error(
      `cannot get keys from not an object. Got ${obj.schema.type}`,
      { cause: { schema: obj.schema, instance: obj } }
    );
  }
  const schemas = Object.keys(obj.schema.properties).map(
    (prop) => constant(prop)
  );
  return or(...schemas);
}
var UnknownSchemaBuilder = class extends SchemaBuilder {
  constructor() {
    super({});
  }
};
function any() {
  return new UnknownSchemaBuilder();
}
function unknown() {
  return new UnknownSchemaBuilder();
}
var NeverSchemaBuilder = class extends SchemaBuilder {
  constructor() {
    super({ not: {} });
  }
};
function never() {
  return new NeverSchemaBuilder();
}
var NotSchemaBuilder = class extends SchemaBuilder {
  constructor(schema) {
    super({
      not: schema.schema
    });
  }
};
function not(def) {
  return new NotSchemaBuilder(def);
}
function fromJSON(externalJsonSchema, baseSchema = any()) {
  baseSchema.schema = { ...baseSchema.schema, ...externalJsonSchema };
  return baseSchema;
}
function injectAjv(ajv, schemaBuilderFn) {
  return new Proxy(schemaBuilderFn, {
    apply(target, thisArg, argArray) {
      const result = Reflect.apply(target, thisArg, argArray);
      result.ajv = ajv;
      return result;
    }
  });
}
function create(ajv) {
  return {
    number: injectAjv(ajv, number),
    integer: injectAjv(ajv, integer),
    int: injectAjv(ajv, integer),
    string: injectAjv(ajv, string),
    null: injectAjv(ajv, nil),
    enum: injectAjv(ajv, makeEnum),
    nativeEnum: injectAjv(ajv, makeEnum),
    boolean: injectAjv(ajv, boolean),
    object: injectAjv(ajv, object),
    keyof: injectAjv(ajv, keyof),
    record: injectAjv(ajv, record),
    array: injectAjv(ajv, array),
    tuple: injectAjv(ajv, tuple),
    const: injectAjv(ajv, constant),
    literal: injectAjv(ajv, constant),
    unknown: injectAjv(ajv, unknown),
    any: injectAjv(ajv, any),
    never: injectAjv(ajv, never),
    or: injectAjv(ajv, or),
    union: injectAjv(ajv, or),
    and: injectAjv(ajv, and),
    intersection: injectAjv(ajv, and),
    not: injectAjv(ajv, not),
    fromJSON
  };
}

// src/schema/types.ts
var types_exports = {};

// src/index.ts
var src_default = builder_exports;
export {
  DEFAULT_AJV as Ajv,
  DEFAULT_AJV,
  SchemaBuilder,
  types_exports as SchemaType,
  and,
  any,
  array,
  boolean,
  constant as const,
  create,
  src_default as default,
  makeEnum as enum,
  fromJSON,
  integer as int,
  integer,
  and as intersection,
  keyof,
  constant as literal,
  makeEnum as nativeEnum,
  never,
  create as new,
  not,
  nil as null,
  number,
  object,
  or,
  record,
  builder_exports as s,
  string,
  tuple,
  or as union,
  unknown
};
