import * as ajv_dist_core from 'ajv/dist/core';
import Ajv, { SchemaObject } from 'ajv';

/**
 * Base schema with internal properties.
 * It also index-based type.
 */
type BaseSchema = SchemaObject & {
    anyOf?: AnySchemaOrAnnotation[];
    oneOf?: AnySchemaOrAnnotation[];
    allOf?: AnySchemaOrAnnotation[];
    not?: AnySchemaOrAnnotation;
    type?: string;
    $ref?: string;
    $async?: boolean;
    /**
     * ## New in draft 7
     * The `$comment` keyword is strictly intended for adding comments to a schema.
     * Its value must always be a string. Unlike the annotations {@link BaseSchema.title `title`},
     * {@link BaseSchema.description `description`}, and {@link BaseSchema.examples `examples`},
     * JSON schema implementations aren’t allowed to attach any meaning or behavior to it whatsoever,
     * and may even strip them at any time. Therefore, they are useful for leaving notes to future editors
     * of a JSON schema, but should not be used to communicate to users of the schema.
     * @see {@link https://json-schema.org/understanding-json-schema/reference/generic.html#comments comment}
     */
    $comment?: string;
    /**
     * The `title` keyword must be string. A `title` will preferably be short.
     */
    title?: string;
    /**
     * The `description` keyword must be string. A {@link BaseSchema.title `title`} will preferably be short,
     * whereas a `description` will provide a more lengthy explanation about
     * the purpose of the data described by the schema.
     *
     */
    description?: string;
    default?: unknown;
    /**
     * ## New in draft 6
     * The examples keyword is a place to provide an array of examples that validate against the schema.
     * This isn’t used for validation, but may help with explaining the effect and purpose of the schema
     * to a reader. Each entry should validate against the schema in which it resides,
     * but that isn’t strictly required. There is no need to duplicate the default value in the examples array,
     * since default will be treated as another example.
     */
    examples?: unknown[];
    /**
     * ## New in draft 2019-09
     * The `deprecated` keyword is a boolean that indicates that the instance value the keyword applies
     * to should not be used and may be removed in the future.
     */
    deprecated?: boolean;
    /**
     * ## New in draft 7
     * The boolean keywords `readOnly` and `writeOnly` are typically used in an API context.
     * `readOnly` indicates that a value should not be modified.
     * It could be used to indicate that a PUT request that changes a value would result in
     * a `400 Bad Request` response.
     */
    readOnly?: boolean;
    /**
     * ## New in draft 7
     * The boolean keywords `readOnly` and `writeOnly` are typically used in an API context.
     * `writeOnly` indicates that a value may be set, but will remain hidden.
     * In could be used to indicate you can set a value with a `PUT` request,
     * but it would not be included when retrieving that record with a `GET` request.
     */
    writeOnly?: boolean;
};
/** Schema string pattern */
type Pattern = string;
/**
 * There are two numeric types in JSON Schema:
 * {@link https://json-schema.org/understanding-json-schema/reference/numeric.html#id4 `integer`} and
 * {@link https://json-schema.org/understanding-json-schema/reference/numeric.html#number `number`}.
 * They share the same validation keywords.
 *
 * **NOTE:** JSON has no standard way to represent complex numbers, so there is no way to test for them in JSON Schema.
 */
type NumberSchema = BaseSchema & {
    /**
     * The integer type is used for integral numbers. JSON does not have distinct types for integers and floating-point values.
     * Therefore, the presence or absence of a decimal point is not enough to distinguish between integers and non-integers.
     * For example, `1` and `1.0` are two ways to represent the same value in JSON.
     * JSON Schema considers that value an integer no matter which representation was used.
     *
     * The number type is used for any numeric type, either integers or floating point numbers.
     *
     * @example
     * // integer
     * { "type": "integer" }
     * 42 // good
     * 1.0 // good
     * -1 // good
     * 3.1415926 // bad. Floating point numbers are rejected
     * "14" // bad. Numbers as strings are rejected
     *
     * { "type": "number" }
     * 42 // good
     * -1 // good
     * 2.99792458e8 // good
     * "42" // bad
     * @type {('number' | 'integer')}
     */
    type: 'number' | 'integer';
    /**
     * If `x` is the value being validated, the following must hold true:
     * - x ≥ `minimum`
     * - x > `exclusiveMinimum`
     * - x ≤ `maximum`
     * - x < `exclusiveMaximum`
     *
     * @type {number}
     */
    minimum?: number;
    /**
     * If `x` is the value being validated, the following must hold true:
     * - x ≥ `minimum`
     * - x > `exclusiveMinimum`
     * - x ≤ `maximum`
     * - x < `exclusiveMaximum`
     *
     * @type {number}
     */
    maximum?: number;
    /**
     * Numbers can be restricted to a multiple of a given number, using the `multipleOf` keyword. It may be set to any positive number.
     * @example
     * // good
     * 0
     * 10
     * 20
     * // Bad
     * 23 // Not a multiple of 10:
     * @type {number}
     */
    multipleOf?: number;
    /**
     * If `x` is the value being validated, the following must hold true:
     * - x ≥ `minimum`
     * - x > `exclusiveMinimum`
     * - x ≤ `maximum`
     * - x < `exclusiveMaximum`
     *
     * @type {number}
     */
    exclusiveMaximum?: number | boolean;
    /**
     * If `x` is the value being validated, the following must hold true:
     * - x ≥ `minimum`
     * - x > `exclusiveMinimum`
     * - x ≤ `maximum`
     * - x < `exclusiveMaximum`
     *
     * @type {number}
     */
    exclusiveMinimum?: number | boolean;
    format?: 'int32' | 'double' | 'int64' | 'float';
};
/**
 * The `string` type is used for strings of text. It may contain Unicode characters.
 */
type StringSchema = BaseSchema & {
    type: 'string';
    /**
     * The length of a string can be constrained using the `minLength` and `maxLength` keywords. For both keywords, the value must be a non-negative number.
     *
     * @type {number}
     */
    minLength?: number;
    /**
     * The length of a string can be constrained using the `minLength` and `maxLength` keywords. For both keywords, the value must be a non-negative number.
     *
     * @type {number}
     */
    maxLength?: number;
    /**
     * Regex pattern
     * @example
     * const mySchema = {
     * "type": "string",
     * "pattern": "^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$"
     * }
     *
     * validate("555-1212", mySchema) // ok
     * validate("(888)555-1212", mySchema) // ok
     * validate("(888)555-1212 ext. 532", mySchema) // error
     * validate("(800)FLOWERS", mySchema) // error
     *
     * @type {Pattern}
     */
    pattern?: Pattern;
    format?: 'date-time' | 'time' | 'date' | 'duration' | 'email' | 'idn-email' | 'hostname' | 'idn-hostname' | 'ipv4' | 'ipv6' | 'uuid' | 'uri' | 'uri-reference' | 'iri' | 'iri-reference' | 'uri-template' | 'json-pointer' | 'relative-json-pointer' | 'regex';
};
/**
 * The boolean type matches only two special values: `true` and `false`.
 *
 * **Note** that values that evaluate to `true` or `false`, such as `1` and `0`, are not accepted by the schema.
 */
type BooleanSchema = BaseSchema & {
    type: 'boolean';
};
/**
 * When a schema specifies a type of null, it has only one acceptable value: null.
 *
 * **NOTE:** It’s important to remember that in JSON, null isn’t equivalent to something being absent.
 * See {@link https://json-schema.org/understanding-json-schema/reference/object.html#required Required Properties} for an example.
 */
type NullSchema = BaseSchema & {
    type: 'null';
};
/**
 * Combine schema.
 * @example
 * {type: ['string', 'number']}
 * 123 // OK
 * "Some" // OK
 * {} //error. not matched the type
 */
type CombinedSchema = BaseSchema & {
    type: AnySchema['type'][];
};
type EnumAnnotation = {
    enum: (number | string | boolean | null | object)[];
};
type ConstantAnnotation = {
    const: number | string | boolean | null | object;
};
/** Any schema definition */
type AnySchema = ObjectSchema | NumberSchema | StringSchema | NullSchema | BooleanSchema | ArraySchema;
/**
 * Any Schema and any annotation
 * @see {@link EnumAnnotation}
 * @see {@link ConstantAnnotation}
 */
type AnySchemaOrAnnotation = AnySchema | EnumAnnotation | ConstantAnnotation | CombinedSchema;
type MaybeReadonlyArray<T> = T[] | readonly T[];
/**
 * Objects are the mapping type in JSON. They map `keys` to `values`. In JSON, the `keys` must always be strings. Each of these pairs is conventionally referred to as a `property`.
 * @see {@link https://json-schema.org/understanding-json-schema/reference/object.html JSON Schema object definition}
 * @todo improve object schema definition for required and additional properties
 */
type ObjectSchema = BaseSchema & {
    type: 'object';
    /**
     * The `properties` (key-value pairs) on an object are defined using the `properties` keyword.
     * The value of `properties` is an object, where each key is the name of a property and each value
     * is a schema used to validate that property. Any property that doesn’t match any of the property names
     * in the `properties` keyword is ignored by this keyword.
     *
     * **NOTE:** See Additional Properties and Unevaluated Properties for how to disallow properties that don’t match any of the property names in `properties`.
     * @see https://json-schema.org/understanding-json-schema/reference/object.html#properties
     * @example
     * {
     * type: "object",
     * properties: {
     *   number: { "type": "number" },
     *   street_name: { "type": "string" },
     *   street_type: { "enum": ["Street", "Avenue", "Boulevard"] }
     * }
     * }
     * { "number": 1600, "street_name": "Pennsylvania", "street_type": "Avenue" } // good
     * { "number": "1600", "street_name": "Pennsylvania", "street_type": "Avenue" } // error: number in wrong format
     * { } // valid
     * { "number": 1600, "street_name": "Pennsylvania", "street_type": "Avenue", "direction": "NW" } // valid for additional properties
     */
    properties?: Record<string, AnySchemaOrAnnotation>;
    /**
     * Sometimes you want to say that, given a particular kind of property name, the value should match
     * a particular schema. That’s where patternProperties comes in: it maps regular expressions to schemas.
     * If a property name matches the given regular expression, the property value must validate against the corresponding schema.
     *
     * **NOTE:** Regular expressions are not anchored. This means that when defining the regular expressions for `patternProperties`,
     * it’s important to note that the expression may match anywhere within the property name.
     * For example, the regular expression `p` will match any property name with a p in it, such as `apple`,
     * not just a property whose name is simply `p`. It’s therefore usually less confusing to surround the regular expression in
     * `^...$`, for example, `^p$`.
     * @example
     * {
     * "type": "object",
     * "patternProperties": {
     *   "^S_": { "type": "string" },
     *   "^I_": { "type": "integer" }
     * }
     * }
     * { "S_25": "This is a string" } // good
     * { "I_0": 42 } // valid
     * { "S_0": 42 } // error: name starts with S_, it must be a string
     * { "I_42": "This is a string" } // error: the name starts with I_, it must be an integer
     */
    patternProperties?: Record<Pattern, AnySchemaOrAnnotation>;
    dependentRequired?: Record<string, string[]>;
    /**
     * The additionalProperties keyword is used to control the handling of extra stuff, that is,
     * properties whose names are not listed in the properties keyword or match any of
     * the regular expressions in the patternProperties keyword. By default any additional properties are allowed.
     * The value of the additionalProperties keyword is a schema that will be used to validate any properties
     * in the instance that are not matched by properties or patternProperties.
     * Setting the additionalProperties schema to false means no additional properties will be allowed.
     * @see {@link ObjectSchema.properties}
     * @see {@link https://json-schema.org/understanding-json-schema/reference/object.html}
     * @example
     * {
     * "type": "object",
     * "properties": {
     *   "number": { "type": "number" },
     * },
     * "additionalProperties": false
     * }
     * { "number": 1600, } // ok
     * { "number": 1600,"direction": "NW" } // error. Since `additionalProperties` is false, this extra property “direction” makes the object invalid
     */
    additionalProperties?: boolean | AnySchemaOrAnnotation;
    optionalProperties?: Record<string, AnySchemaOrAnnotation>;
    /**
     * By default, the properties defined by the properties keyword are not required.
     * However, one can provide a list of required properties using the required keyword.
     * The required keyword takes an array of zero or more strings. Each of these strings must be unique.
     */
    required?: MaybeReadonlyArray<string>;
    unevaluatedProperties?: boolean;
    /**
     * ## New in draft 6
     * The names of properties can be validated against a schema, irrespective of their values.
     * This can be useful if you don’t want to enforce specific properties,
     * but you want to make sure that the names of those properties follow a specific convention.
     * You might, for example, want to enforce that all names are valid ASCII tokens so they can be
     * used as attributes in a particular programming language.
     * @since draft 6
     * @example
     * {
     * "type": "object",
     * "propertyNames": {
     *   "pattern": "^[A-Za-z_][A-Za-z0-9_]*$"
     * }
     * }
     * //usage
     * { "_a_proper_token_001": "value" } // ok
     * { "001 invalid": "value"} // error. not matched the pattern
     */
    propertyNames?: {
        pattern: Pattern;
    };
    nullable?: boolean;
    minProperties?: number;
    maxProperties?: number;
};
/**
 * Arrays are used for ordered elements. In JSON, each element in an array may be of a different type.
 * @see {@link https://json-schema.org/understanding-json-schema/reference/array.html}
 * @todo improve complex type e.g. `(string|number)[]`
 */
type ArraySchema = BaseSchema & {
    type: 'array';
    uniqueItems?: boolean;
    items?: boolean | AnySchemaOrAnnotation | AnySchemaOrAnnotation[];
    minItems?: number;
    maxItems?: number;
    prefixItems?: AnySchemaOrAnnotation[];
    contains?: AnySchemaOrAnnotation;
    minContains?: number;
    maxContains?: number;
};

type types_AnySchema = AnySchema;
type types_AnySchemaOrAnnotation = AnySchemaOrAnnotation;
type types_ArraySchema = ArraySchema;
type types_BaseSchema = BaseSchema;
type types_BooleanSchema = BooleanSchema;
type types_CombinedSchema = CombinedSchema;
type types_ConstantAnnotation = ConstantAnnotation;
type types_EnumAnnotation = EnumAnnotation;
type types_NullSchema = NullSchema;
type types_NumberSchema = NumberSchema;
type types_ObjectSchema = ObjectSchema;
type types_StringSchema = StringSchema;
declare namespace types {
  export type { types_AnySchema as AnySchema, types_AnySchemaOrAnnotation as AnySchemaOrAnnotation, types_ArraySchema as ArraySchema, types_BaseSchema as BaseSchema, types_BooleanSchema as BooleanSchema, types_CombinedSchema as CombinedSchema, types_ConstantAnnotation as ConstantAnnotation, types_EnumAnnotation as EnumAnnotation, types_NullSchema as NullSchema, types_NumberSchema as NumberSchema, types_ObjectSchema as ObjectSchema, types_StringSchema as StringSchema };
}

type UUID = `${string}-${string}-${string}-${string}-${string}`

type Email = `${string}@${string}.${string}`

/** `T > U` */
type GreaterThan<T extends number, U extends number> = Create<U> extends [...Create<T>, ...infer _] ? false : true;
/** `T >= U` */
type GreaterThanOrEqual<T extends number, U extends number> = Equal<T, U> extends true ? true : GreaterThan<T, U>

/** `T < U` */
type LessThan<T extends number, U extends number> = GreaterThanOrEqual<T, U> extends true ? false : true

/** `T === U` */
type Equal<T extends number, U extends number> = Create<U>['length'] extends Create<T>['length'] ? true : false;

type IsFloat<N extends number | string> = N extends number
  ? IsFloat<`${N}`>
  : N extends `${number}.${number extends 0 ? '' : number}`
  ? true
  : false

type IsNegative<N extends number | string> = N extends number
  ? IsNegative<`${N}`>
  : N extends `-${number}`
  ? true
  : false

type IsPositiveInteger<N extends number | string> = IsFloat<N> extends true
  ? false
  : IsNegative<N> extends true
  ? false
  : true

type Create<
  L extends number,
  T = unknown,
  U extends T[] = []
> = IsPositiveInteger<L> extends true ? U['length'] extends L ? U : Create<L, T, [T, ...U]> : never;

type MakeReadonly<T extends readonly unknown[]> = readonly T

type Optional<T extends readonly unknown[]> = T extends [infer First, ...infer Rest] ? [First?, ...Optional<Rest>] : T

/**
 * UnionToIntersection<{ foo: string } | { bar: string }> =
 *  { foo: string } & { bar: string }.
 */
type UnionToIntersection<U> = (
  U extends unknown ? (arg: U) => 0 : never
) extends (arg: infer I) => 0
  ? I
  : never;

/**
 * LastInUnion<1 | 2> = 2.
 */
type LastInUnion<U> = UnionToIntersection<
  U extends unknown ? (x: U) => 0 : never
> extends (x: infer L) => 0
  ? L
  : never;

/**
 * UnionToTuple<1 | 2> = [1, 2].
 */
type UnionToTuple<U, Last = LastInUnion<U>> = [U] extends [never]
  ? []
  : [...UnionToTuple<Exclude<U, Last>>, Last];

type Fn<
  R = unknown,
  Args extends readonly unknown[] = [],
  This = void
> = (this: This, ...args: Args) => R

/**
* A TypeScript type alias called `Prettify`.
* It takes a type as its argument and returns a new type that has the same properties as the original type, 
* but the properties are not intersected. This means that the new type is easier to read and understand.
*/
type Prettify<T> = {
  [K in keyof T]: T[K]
} & {}
/**
 * @example
 * interface User {
 *   name?: string
 *   age?: number
 *   address?: string
 * }
 *
 * type UserRequiredName = RequiredByKeys<User, 'name'>
 * // { name: string; age?: number; address?: string }
 * @see https://github.com/type-challenges/type-challenges/issues/3180
 */
type RequiredByKeys<T, K = keyof T> = {
  [P in keyof T as P extends K ? never : P]: T[P]
} & {
    [P in keyof T as P extends K ? P : never]-?: T[P]
  } extends infer I
  ? { [P in keyof I]: I[P] }
  : never

type Merge$1<T> = {
  [K in keyof T]: T[K]
}

type OptionalByKey<T, K extends keyof T> = Omit<T, K> & { [Key in K]?: T[Key] }

type InferKeys<T> = T extends Record<infer K, any> ? K : never;

type OptionalUndefined<
  T,
  Props extends keyof T = keyof T,
  OptionsProps extends keyof T =
  Props extends keyof T ?
  undefined extends T[Props] ?
  Props : never
  : never
> =
  Prettify<Merge$1<{
    [K in OptionsProps]?: T[K]
  } & {
      [K in Exclude<keyof T, OptionsProps>]: T[K]
    }>>

type IndexType<T, Index = unknown> = {
  [K in keyof T]: T[K]
} & {
    [K in string]: Index
  }

type OmitMany<T, Keys extends (keyof T)[]> = Omit<T, Keys[number]>

type OmitByValue<T, V> = {
  [K in keyof T as T[K] extends V ? never: K]: T[K]
}

type PickMany<T, Fields extends (keyof T)[]> = Pick<T, Fields[number]>

type TGenericError<Message extends string, Rest extends unknown[] = []> = [
  never,
  Message,
  ...Rest,
]

type TTypeGenericError<Message extends string, Rest extends unknown[] = []> = TGenericError<`TypeError: ${Message}`, Rest>
type TRangeGenericError<Message extends string, Rest extends unknown[] = []> = TGenericError<`RangeError: ${Message}`, Rest>

/**
 * Default Ajv instance.
 *
 * @default
 * ajvErrors(addFormats(new Ajv({
 *  allErrors: true,
 *  useDefaults: true,
 * })))
 */
declare const DEFAULT_AJV: ajv_dist_core.default;
/** Any schema builder. */
type AnySchemaBuilder = SchemaBuilder<any, any, any, any> | NumberSchemaBuilder | StringSchemaBuilder | BooleanSchemaBuilder | NullSchemaBuilder | ObjectSchemaBuilder | RecordSchemaBuilder | ArraySchemaBuilder | TupleSchemaBuilder | EnumSchemaBuilder | ConstantSchemaBuilder | UnionSchemaBuilder | IntersectionSchemaBuilder | UnknownSchemaBuilder<unknown> | NotSchemaBuilder;
type MetaObject = PickMany<BaseSchema, [
    "title",
    "description",
    "deprecated",
    "$id",
    "$async",
    "$ref",
    "$schema"
]>;
type SafeParseResult<T> = SafeParseSuccessResult<T> | SafeParseErrorResult<T>;
type SafeParseSuccessResult<T> = {
    success: true;
    data: T;
    input: unknown;
    /** `undefined` for success result */
    error?: Error;
};
type SafeParseErrorResult<T> = {
    success: false;
    error: Error;
    input: unknown;
    /** `undefined` for error result */
    data?: T;
};
type ErrorMessageParams<T extends AnySchemaBuilder> = {
    /** Error message for not expected type. E.g. schema define string, but got number */
    type?: string;
    /** Error message for `required` property. E.g. schema define required property, but in actial result this property missing. */
    required?: T extends ObjectSchemaBuilder ? {
        [K in keyof Infer<T>]?: string;
    } | string : string;
    /** Error message for properties. Mostly works for object, arrays */
    properties?: T extends ObjectSchemaBuilder ? {
        [K in keyof Infer<T>]?: string;
    } | string : string;
    /** Error message for additional properties. Mostly works for object, arrays */
    additionalProperties?: string;
    /** Default or unmapped error message */
    _?: string;
};
type SchemaBuilderOpts = {
    _preProcesses: Fn<any, any, any>[];
    _postProcesses: Fn<any, any, any>[];
};
declare class SchemaBuilder<Input = unknown, Schema extends AnySchemaOrAnnotation = AnySchemaOrAnnotation, Output = Input, Opts extends SchemaBuilderOpts = {
    _preProcesses: [];
    _postProcesses: [];
}> {
    private _ajv;
    /**
     * type helper. Do Not Use!
     */
    _input: Input;
    /**
     * type helper. Do Not Use!
     */
    _output: Output;
    private _schema;
    private _shape;
    _preProcesses: Opts['_preProcesses'];
    _postProcesses: Opts['_postProcesses'];
    /**
     * returns JSON-schema representation
     */
    get schema(): Schema;
    /**
     * returns JSON-schema representation. same as `schema` does.
     * @satisfies zod API
     */
    get shape(): Schema;
    /**
     * Set custom JSON-Schema representation.
     * Updates `shape` property too
     */
    set schema(schema: Schema);
    /**
     * Set custom JSON-Schema representation.
     * Updates `schema` property too
     * @satisfies zod API
     */
    set shape(schema: Schema);
    /** Returns your ajv instance */
    get ajv(): Ajv;
    /**
     * Set Ajv Instance.
     * @throws `TypeError` if not ajv instance comes
     */
    set ajv(instance: Ajv);
    constructor(schema: Schema, _ajv?: ajv_dist_core.default);
    protected isNullable: boolean;
    /**
     * set custom JSON-schema field. Useful if you need to declare something but no api founded for built-in solution.
     *
     * Example: `If-Then-Else` you cannot declare without `custom` method.
     * @example
     * const myObj = s.object({
     *  foo: s.string(),
     *  bar: s.string()
     * }).custom('if', {
     *  "properties": {
     *    "foo": { "const": "bar" }
     *  },
     *  "required": ["foo"]
     *  }).custom('then', { "required": ["bar"] })
     */
    custom<V = unknown, Result extends AnySchemaBuilder = this>(key: string, value: V): Result;
    /**
     * Marks your property as nullable (`undefined`)
     *
     * **NOTES**: json-schema not accept `undefined` type. It's just `nullable` as typescript `undefined` type.
     */
    optional(): SchemaBuilder<Input, Schema, Output | undefined>;
    /**
     * Marks your property as nullable (`null`).
     *
     * Updates `type` property for your schema.
     * @example
     * const schemaDef = s.string().nullable()
     * schemaDef.schema // { type: ['string', 'null'], nullable: true }
     */
    nullable(): SchemaBuilder<Input, Schema, Output | null>;
    private preFns;
    /**
     * pre process function for incoming result. Transform input **BEFORE** calling `parse`, `safeParse`, `validate` functions
     *
     * **NOTE:** this functions works BEFORE parsing. use it at own risk. (e.g. transform Date object into string)
     * @see {@link SchemaBuilder.parse parse} method
     * @see {@link SchemaBuilder.safeParse safe parse} method
     * @see {@link SchemaBuilder.validate validate} method
     * @example
     * const myString = s.string().preprocess(v => {
     *   // if date => transform to ISO string
     *   if(v instanceof Date) {
     *     return Date.toISOString()
     *   }
     *  // do nothing if not a date
     *   return v
     * })
     * const res = myString.parse(new Date()) // '2023-09-23T07:10:57.881Z'
     * const res = myString.parse('qwe') // 'qwe'
     * const res = myString.parse({}) // error: not a string
     */
    preprocess<const In, const Out, const F extends Fn<any, any>>(fn: F): this;
    private postFns;
    /**
     * Post process. Use it when you would like to transform result after parsing is happens.
     *
     * **NOTE:** this function override your `input` variable for `safeParse` calling.
     * @see {@link SchemaBuilder.safeParse safeParse method}
     */
    postprocess<const Out, S extends AnySchemaBuilder = AnySchemaBuilder>(fn: Fn<Out, [input: Output, schema: this]>, schema: S): this;
    private refineFns;
    /**
     * Set custom validation. Any result exept `undefined` will throws.
     * @param fn function that will be called after `safeParse`. Any result will throws
     * @example
     * import s from 'ajv-ts'
     * // example: object with only 1 "active element"
     * const Schema = s.object({
     * active: s.boolean(),
     * name: s.string()
     * }).array().refine((arr) => {
     *  const subArr = arr.filter(el => el.active === true)
     *  if (subArr.length > 1) throw new Error('Array should contains only 1 "active" element')
     * })
     *
     * Schema.parse([{ active: true, name: 'some 1' }, { active: true, name: 'some 2' }]) // throws Error
     */
    refine(fn: (output: Output) => any): this;
    /**
     * Meta object. Adds meta information fields in your schema, such as `deprecated`, `description`, `$id`, `title` and more!
     */
    meta(obj: MetaObject): this;
    /**
     * Option `default` keywords throws exception during schema compilation when used in:
     *
     * - not in `properties` or `items` subschemas
     * - in schemas inside `anyOf`, `oneOf` and `not` ({@link https://github.com/ajv-validator/ajv/issues/42 #42})
     * - in `if` schema
     * - in schemas generated by user-defined _macro_ keywords
     * This means only `object()` and `array()` buidlers are supported.
     * @see {@link object}
     * @see {@link array}
     * @example
     * import s from 'ajv-ts'
     * const Person = s.object({
     *   age: s.int().default(18)
     * })
     * Person.parse({}) // { age: 18 }
     */
    default(value: Output): this;
    /**
     * Defines custom error message for invalid schema.
     *
     * Set `schema.errorMessage = message` under the hood.
     * @example
     * // number example
     * const numberSchema = s.number().error('Not a number')
     * numberSchema.parse('qwe') // error: Not a number
     */
    error(messageOrOptions: string | ErrorMessageParams<this>): this;
    /**
     * set `description` for your schema.
     * You can use `meta` method to provide information in more consistant way.
     * @see {@link SchemaBuilder.meta meta} method
     * @satisfies `zod` API
     */
    describe(message: string): this;
    /**
     * set `$async=true` for your current schema.
     *
     * @see {@link https://ajv.js.org/guide/async-validation.html ajv async validation}
     */
    async(): this;
    /**
     * set `$async=false` for your current schema.
     * @param [remove=false] applies `delete` operator for `schema.$async` property.
     */
    sync(remove?: boolean): this;
    /**
     * Construct Array schema. Same as `s.array(s.number())`
     *
     * @see {@link array}
     */
    array<El = Infer<this>>(): ArraySchemaBuilder<El, El[], this, {
        maxLength: undefined;
        minLength: undefined;
        prefix: [];
    }>;
    /**
     * Same as `s.and()`. Combine current type with another. Logical "AND"
     *
     * Typescript `A & B`
     */
    intersection: typeof this.and;
    /**
     * Same as `s.and()`. Combine current type with another. Logical "AND"
     *
     * Typescript `A & B`
     */
    and<S extends AnySchemaBuilder[] = AnySchemaBuilder[], Arr extends AnySchemaBuilder[] = [this, ...S]>(...others: S): IntersectionSchemaBuilder<Arr>;
    /**
     * Same as `s.or()`. Combine current type with another type. Logical "OR"
     *
     * Typescript: `A | B`
     */
    or<S extends AnySchemaBuilder[] = AnySchemaBuilder[]>(...others: S): UnionSchemaBuilder<[this, ...S]>;
    /**
     * Same as `s.or()`. Combine current type with another type. Logical "OR"
     *
     * Typescript: `A | B`
     */
    union: typeof this.or;
    /**
     * Exclude given subschema.
     *
     * Append `not` keyword for your schema
     *
     * @see {@link not}
     * @see {@link SchemaBuilder.not not method}
     * @example
     * cosnt res = s
     *   .string<'Jerry' | 'Martin'>()
     *   .exclude(s.const('Jerry'))
     *   .schema // {type: "string", not: {const: "Jerry"} }
     * type Res = s.infer<typeof res> // 'Martin'
     */
    exclude<S extends SchemaBuilder<any, any, any> = SchemaBuilder<any, any, any>, Excl = Exclude<this["_output"], S['_output']>, This = this extends StringSchemaBuilder<infer S> ? StringSchemaBuilder<Excl extends string ? Excl : S> : this extends NumberSchemaBuilder<infer N> ? NumberSchemaBuilder<Excl extends number ? Excl : N> : this extends BooleanSchemaBuilder<infer B> ? BooleanSchemaBuilder<Excl extends boolean ? Excl : B> : this extends ArraySchemaBuilder<infer E> ? ArraySchemaBuilder<Exclude<E, S["_output"]>> : this extends ObjectSchemaBuilder<infer Def extends ObjectDefinition> ? ObjectSchemaBuilder<OmitByValue<Def, S>> : this>(s: S): This;
    /**
     * Exclude self schema.
     *
     * Wrap your schema with `not` keyword
     *
     * `s.not(s.string())` === `s.string().not()`
     *
     * If you need to append `not` keyword instead of wrap you might need to use {@link SchemaBuilder.exclude `exclude`} method
     *
     * @see {@link not}
     * @see {@link SchemaBuilder.exclude exclude method}
     *
     * @example
     * // not string
     * s
     *   .string()
     *   .not()
     *   .schema //  {not: { type: "string" }},
     */
    not<S extends AnySchemaBuilder = this>(): NotSchemaBuilder<S>;
    private _transform;
    private _safeParseRaw;
    /**
     * Parse you input result. Used `ajv.validate` under the hood
     *
     * It also applies your `postProcess` functions if parsing was successfull
     */
    safeParse<const I>(input?: I): SafeParseResult<Output>;
    /**
     * Validate your schema.
     *
     * @returns {boolean} Validity of your schema
     */
    validate(input?: unknown): input is Output;
    /**
     * Parse input for given schema.
     *
     * @returns {Output} parsed output result.
     * @throws `Error` when input not match given schema
     */
    parse<const I>(input?: I): Output;
}
declare class NumberSchemaBuilder<const N extends number = number, Opts extends SchemaBuilderOpts = {
    _preProcesses: [];
    _postProcesses: [];
}> extends SchemaBuilder<number, NumberSchema, N> {
    constructor();
    /**
     * change schema type from `any integer number` to `any number`.
     *
     * Set schema `{type: 'number'}`
     *
     * This is default behavior
     */
    number(): this;
    /**
     * The `const` keyword is used to restrict a value to a single value.
     * @example
     * const a = s.number().const(5)
     * a.schema // {type: "number", const: 5}
     * s.infer<typeof a> // 5
     */
    const<const N extends number>(value: N): NumberSchemaBuilder<N>;
    /** Set schema `{type: 'integer'}` */
    integer(): this;
    /**
     * Appends format for your number schema.
     */
    format(type: NumberSchema["format"]): this;
    /** Getter. Retuns `minimum` or `exclusiveMinimum` depends on your schema definition */
    get minValue(): number;
    /** Getter. Retuns `maximum` or `exclusiveMaximum` depends on your schema definition */
    get maxValue(): number;
    min: (value: number, exclusive?: boolean) => this;
    /**
     * Provides minimum value
     *
     * Set schema `minimum = value` (and add `exclusiveMinimum = true` if needed)
     * @example
     * s.number().min(2, true) // > 2
     * s.number().min(2) // >= 2
     */
    minimum(value: number, exclusive?: boolean): this;
    step: (value: number) => this;
    /**
     * Numbers can be restricted to a multiple of a given number, using the `multipleOf` keyword.
     * It may be set to any positive number. Same as `step`.
     *
     * **NOTE**: Since JSON schema odes not allow to use `multipleOf` with negative value - we use `Math.abs` to transform negative values into positive
     * @see {@link NumberSchemaBuilder.step step}
     * @example
     * const a = s.number().multipleOf(10)
     *
     * a.parse(10) // ok
     * a.parse(9) // error
     *
     * const b = s.number().multipleOf(-0.1)
     * b.parse(1.1) // ok, step is `0.1`
     * b.parse(1) // error, step is not `0.1`
     */
    multipleOf(value: number): this;
    max: (value: number, exclusive?: boolean) => this;
    /**
     * marks you number maximum value
     */
    maximum(value: number, exclusive?: boolean): this;
    /**
     * Greater than
     *
     * @see {@link NumberSchemaBuilder.maximum}
     * @see {@link NumberSchemaBuilder.gte}
     */
    gt(value: number): this;
    /**
     * Greater than or equal
     *
     * Range: `[value; Infinity)`
     * @see {@link NumberSchemaBuilder.maximum maximum}
     * @see {@link NumberSchemaBuilder.gt gt}
     */
    gte(value: number): this;
    /**
     * Less than
     *
     * Range: `(value; Infinity)`
     * @see {@link NumberSchemaBuilder.minimum minimum}
     * @see {@link NumberSchemaBuilder.lte lte}
     */
    lt(value: number): this;
    /**
     * Less than or Equal
     *
     * Range: `[value; Infinity)`
     * @see {@link NumberSchemaBuilder.minimum}
     * @see {@link NumberSchemaBuilder.lt}
     */
    lte(value: number): this;
    /** Any positive number (greater than `0`)
     * Range: `(0; Infinity)`
     */
    positive(): this;
    /** Any non negative number (greater than or equal `0`)
     *
     * Range: `[0; Inifnity)`
     */
    nonnegative(): this;
    /** Any negative number (less than `0`)
     *
     * Range: `(Inifinity; 0)`
     */
    negative(): this;
    /** Any non postive number (less than or equal `0`)
     *
     * Range: `(Inifinity; 0]`
     */
    nonpositive(): this;
    /** Marks incoming number between `MAX_SAFE_INTEGER` and `MIN_SAFE_INTEGER` */
    safe(): this;
}
/**
 * Construct `number` schema.
 *
 * **NOTE:** By default Ajv fails `{"type": "number"}` (or `"integer"`)
 * validation for `Infinity` and `NaN`.
 *
 * @example
 * const test1 = s.number()
 *
 * test1.parse(1) // ok
 * test1.parse('qwe') // error
 */
declare function number<const N extends number = number>(): NumberSchemaBuilder<N, {
    _preProcesses: [];
    _postProcesses: [];
}>;
/**
 * construct `integer` schema.
 *
 * Same as `s.number().integer()`
 *
 * **NOTE:** By default Ajv fails `{"type": "integer"}` validation for `Infinity` and `NaN`.
 */
declare function integer(): NumberSchemaBuilder<number, {
    _preProcesses: [];
    _postProcesses: [];
}>;
type StringBuilderOpts = {
    minLength?: number;
    maxLength?: number;
};
declare class StringSchemaBuilder<const S extends string = string, Opts extends StringBuilderOpts & SchemaBuilderOpts = {
    minLength: undefined;
    maxLength: undefined;
    _preProcesses: [];
    _postProcesses: [];
}> extends SchemaBuilder<string, StringSchema, S, Opts> {
    /** DO not use. This is typescript type */
    _opts: Opts;
    /**
     * The `pattern` use regular expressions to express constraints.
     * The regular expression syntax used is from JavaScript ({@link https://www.ecma-international.org/publications-and-standards/standards/ecma-262/ ECMA 262}, specifically).
     * However, that complete syntax is not widely supported, therefore it is recommended that you stick to the subset of that syntax described below.
     *
     * - A single unicode character (other than the special characters below) matches itself.
     * - `.`: Matches any character except line break characters. (Be aware that what constitutes a line break character is somewhat dependent on your platform and language environment, but in practice this rarely matters).
     * - `^`: Matches only at the beginning of the string.
     * - `$`: Matches only at the end of the string.
     * - `(...)`: Group a series of regular expressions into a single regular expression.
     * - `|`: Matches either the regular expression preceding or following the | symbol.
     * - `[abc]`: Matches any of the characters inside the square brackets.
     * - `[a-z]`: Matches the range of characters.
     * - `[^abc]`: Matches any character not listed.
     * - `[^a-z]`: Matches any character outside of the range.
     * - `+`: Matches one or more repetitions of the preceding regular expression.
     * - `*`: Matches zero or more repetitions of the preceding regular expression.
     * - `?`: Matches zero or one repetitions of the preceding regular expression.
     * - `+?`, `*?`, `??`: The *, +, and ? qualifiers are all greedy; they match as much text as possible. Sometimes this behavior isn't desired and you want to match as few characters as possible.
     * - `(?!x)`, `(?=x)`: Negative and positive lookahead.
     * - `{x}`: Match exactly x occurrences of the preceding regular expression.
     * - `{x,y}`: Match at least x and at most y occurrences of the preceding regular expression.
     * - `{x,}`: Match x occurrences or more of the preceding regular expression.
     * - `{x}?`, `{x,y}?`, `{x,}?`: Lazy versions of the above expressions.
     * @example
     * const phoneNumber = s.string().pattern("^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$")
     *
     * phoneNumber.parse("555-1212") // OK
     * phoneNumber.parse("(888)555-1212") // OK
     * phoneNumber.parse("(888)555-1212 ext. 532") // Error
     * phoneNumber.parse("(800)FLOWERS") // Error
     * // typescript custom type
     * const prefixS = s.string().pattern<`S_${string}`>("^S_$")
     * type S = s.infer<typeof prefixS> // `S_${string}`
     * const str1 = prefixS.parse("qwe") // Error
     * const str2 = prefixS.parse("S_Some") // OK
     */
    pattern<Pattern extends string = string>(pattern: string): StringSchemaBuilder<Pattern, Opts>;
    constructor();
    const<V extends string>(value: V): StringSchemaBuilder<V, Opts>;
    /**
     * Define minimum string length.
     *
     * Same as `min`
     * @see {@link StringSchemaBuilder.min min}
     */
    minLength<const L extends number, Valid = IsPositiveInteger<L>, MinLengthValid extends boolean = GreaterThan<L, Opts['maxLength'] extends number ? Opts['maxLength'] : number>>(value: Valid extends true ? MinLengthValid extends true ? L : TRangeGenericError<`MinLength are greater than MaxLength. MinLength: ${L}. MaxLength: ${Opts['maxLength']}`> : TTypeGenericError<`Only Positive and non floating numbers are supported. Received: '${L}'`>): StringSchemaBuilder<S, {
        minLength: L;
        maxLength: Opts['maxLength'];
        _preProcesses: Opts['_preProcesses'];
        _postProcesses: Opts['_postProcesses'];
    }>;
    /**
     * Define minimum string length.
     *
     * Same as `minLength`
     * @see {@link StringSchemaBuilder.minLength minLength}
     */
    min: <const L extends number, Valid = IsPositiveInteger<L>, MinLengthValid extends boolean = GreaterThan<L, Opts["maxLength"] extends number ? Opts["maxLength"] : number>>(value: Valid extends true ? MinLengthValid extends true ? L : TRangeGenericError<`MinLength are greater than MaxLength. MinLength: ${L}. MaxLength: ${Opts["maxLength"]}`> : TTypeGenericError<`Only Positive and non floating numbers are supported. Received: '${L}'`>) => StringSchemaBuilder<S, {
        minLength: L;
        maxLength: Opts["maxLength"];
        _preProcesses: Opts["_preProcesses"];
        _postProcesses: Opts["_postProcesses"];
    }>;
    /**
     * Define maximum string length.
     *
     * Same as `max`
     * @see {@link StringSchemaBuilder.max max}
     */
    maxLength<const L extends number, Valid = IsPositiveInteger<L>, MinLengthValid = LessThan<Opts['minLength'] extends number ? Opts['minLength'] : number, L>>(value: Valid extends true ? MinLengthValid extends true ? L : TRangeGenericError<`MinLength are greater than MaxLength. MinLength: ${Opts['minLength']}. MaxLength: ${L}`> : TTypeGenericError<`Expected positive integer. Received: '${L}'`>): StringSchemaBuilder<S, {
        maxLength: L;
        minLength: Opts['minLength'];
        _preProcesses: Opts['_preProcesses'];
        _postProcesses: Opts['_postProcesses'];
    }>;
    /**
     * Define maximum string length.
     *
     * Same as `maxLength`
     * @see {@link StringSchemaBuilder.maxLength maxLength}
     */
    max: <const L extends number, Valid = IsPositiveInteger<L>, MinLengthValid = LessThan<Opts["minLength"] extends number ? Opts["minLength"] : number, L>>(value: Valid extends true ? MinLengthValid extends true ? L : TRangeGenericError<`MinLength are greater than MaxLength. MinLength: ${Opts["minLength"]}. MaxLength: ${L}`> : TTypeGenericError<`Expected positive integer. Received: '${L}'`>) => StringSchemaBuilder<S, {
        maxLength: L;
        minLength: Opts["minLength"];
        _preProcesses: Opts["_preProcesses"];
        _postProcesses: Opts["_postProcesses"];
    }>;
    /**
     * Define exact string length
     *
     * Same as `s.string().min(v).max(v)`
     *
     * @see {@link StringSchemaBuilder.minLength minLength}
     * @see {@link StringSchemaBuilder.maxLength maxLength}
     * @example
     * const exactStr = s.string().length(3)
     * exactStr.parse('qwe') //Ok
     * exactStr.parse('qwer') // Error
     * exactStr.parse('go') // Error
     */
    length<const L extends number, Valid = IsPositiveInteger<L>>(value: Valid extends true ? L : TTypeGenericError<`Expected positive integer. Received: '${L}'`>): StringSchemaBuilder<S, {
        minLength: L;
        maxLength: L;
        _postProcesses: Opts['_postProcesses'];
        _preProcesses: Opts['_preProcesses'];
    }>;
    /**
     * Define non empty string. Same as `minLength(1)`
     */
    nonEmpty(): StringSchemaBuilder<S, {
        minLength: 1;
        maxLength: Opts['maxLength'];
        _preProcesses: Opts['_preProcesses'];
        _postProcesses: Opts['_postProcesses'];
    }>;
    /**
     * A string is valid against this format if it represents a valid e-mail address format.
     *
     * Example: `some@gmail.com`
     */
    email(): OmitMany<StringSchemaBuilder<Email>, [
        "format",
        "ipv4",
        "ipv6",
        "time",
        "date",
        "dateTime",
        "regex",
        "uuid",
        "email"
    ]>;
    ipv4(): this;
    ipv6(): this;
    /**
     * A Universally Unique Identifier as defined by {@link https://datatracker.ietf.org/doc/html/rfc4122 RFC 4122}.
     *
     * Same as `s.string().format('uuid')`
     *
     * Example: `3e4666bf-d5e5-4aa7-b8ce-cefe41c7568a`
     */
    uuid(): OmitMany<StringSchemaBuilder<UUID>, [
        "format",
        "ipv4",
        "ipv6",
        "time",
        "date",
        "dateTime",
        "regex",
        "uuid",
        "email"
    ]>;
    /**
     * A string is valid against this format if it represents a time in the following format: `hh:mm:ss.sTZD`.
     *
     * Same as `s.string().format('time')`
     *
     * Example: `20:20:39+00:00`
     */
    time(): this;
    /**
     * A string is valid against this format if it represents a date in the following format: `YYYY-MM-DD`.
     *
     * Same as `s.string().format('date')`
     *
     * Example: `2023-10-10`
     */
    date(): this;
    /**
     * A string is valid against this format if it represents a date-time in the following format: `YYYY:MM::DDThh:mm:ss.sTZD`.
     *
     * Same as `s.string().format('date-time')`
     *
     * Example: `2023-10-05T05:49:37.757Z`
     */
    dateTime(): this;
    /**
     * A string is valid against this format if it represents a valid regular expression.
     *
     * Same as `s.string().format('regex')`
     */
    regex(): this;
    format(formatType: StringSchema["format"]): this;
}
/**
 * Construct `string` schema
 */
declare function string<const S extends string = string>(): StringSchemaBuilder<S, {
    minLength: undefined;
    maxLength: undefined;
    _preProcesses: [];
    _postProcesses: [];
}>;
declare class BooleanSchemaBuilder<const B extends boolean = boolean> extends SchemaBuilder<B, BooleanSchema> {
    constructor();
}
/**
 * Construct `boolean` schema
 */
declare function boolean(): BooleanSchemaBuilder<boolean>;
declare class NullSchemaBuilder extends SchemaBuilder<null, NullSchema> {
    constructor();
}
declare function nil(): NullSchemaBuilder;
type ObjectDefinition = {
    [key: string]: SchemaBuilder;
};
type Merge<F, S> = Omit<F, keyof S> & S;
declare class ObjectSchemaBuilder<Definition extends ObjectDefinition = ObjectDefinition, T = {
    [K in keyof Definition]: Infer<Definition[K]>;
}, Out = OptionalUndefined<T>> extends SchemaBuilder<T, ObjectSchema, Out> {
    protected def: Definition;
    constructor(def?: Definition);
    /**
     * set `additionalProperties=true` for your JSON-schema.
     *
     * Opposite of `strict`
     * @see {@link ObjectSchemaBuilder.strict strict}
     */
    passthrough(): ObjectSchemaBuilder<Definition, T & IndexType<T>, IndexType<T>>;
    /**
     * Makes all properties partial(not required)
     */
    partial(): ObjectSchemaBuilder<Definition, Partial<T>, OptionalUndefined<Partial<T>>>;
    /**
     * Makes selected properties partial(not required), rest of them are not changed.
     *
     * Same as for as for `requiredFor('item1').requiredFor('item2')...etc`
     *
     * @example
     * const Test = s.object({
     *  name: s.string(),
     *  email: s.string(),
     * })
     * .required()
     * .partialFor('email')
     *
     * Test.schema === {
     *  type: 'object',
     *  properties: {
     *    "name": {type: 'string'},
     *    "email": {type: 'string'}
     *  }
     *  "required": ['name']
     * }
     */
    partialFor<Key extends keyof T = keyof T>(key: Key): ObjectSchemaBuilder<Definition, OptionalByKey<T, Key>>;
    /**
     * The `dependentRequired` keyword conditionally requires that
     * certain properties must be present if a given property is
     * present in an object. For example, suppose we have a schema
     * representing a customer. If you have their credit card number,
     * you also want to ensure you have a billing address.
     * If you don't have their credit card number, a billing address
     * would not be required. We represent this dependency of one property
     * on another using the `dependentRequired` keyword.
     * The value of the `dependentRequired` keyword is an object.
     * Each entry in the object maps from the name of a property, p,
     * to an array of strings listing properties that are required
     * if p is present.
     *
     * In the following example,whenever a `credit_card` property is provided,
     * a `billing_address` property must also be present:
     * @example
     * const Test1 = s.object({
     * name: s.string(),
     * credit_card: s.number(),
     * billing_address: s.string(),
     * }).requiredFor('name').dependentRequired({
     *   credit_card: ['billing_address'],
     * })
     * Test1.schema === {
     *   "type": "object",
     *   "properties": {
     *     "name": { "type": "string" },
     *     "credit_card": { "type": "number" },
     *     "billing_address": { "type": "string" }
     *   },
     *   "required": ["name"],
     *   "dependentRequired": {
     *     "credit_card": ["billing_address"]
     *   }
     * }
     */
    dependentRequired<Deps = {
        [K in keyof T]?: Exclude<keyof T, K>[];
    }>(dependencies: Deps): ObjectSchemaBuilder<Definition, OptionalByKey<T, InferKeys<Deps> extends keyof T ? InferKeys<Deps> : keyof T>>;
    /**
     * Disallow additional properties for object schema `additionalProperties=false`
     *
     * If you would like to define additional properties type - use `additionalProeprties`
     * @see {@link ObjectSchemaBuilder.additionalProperties additionalProperties}
     */
    strict(): this;
    /**
     * Makes 1 property required, other keys are not required.
     *
     * If some properties is already marked with `requiredFor` - we append new key into `required` JSON schema
     */
    requiredFor<Key extends keyof T = keyof T>(...keys: Key[]): ObjectSchemaBuilder<Definition, RequiredByKeys<T, (typeof keys)[number]>>;
    /**
     * Make **ALL** properties in your object required.
     *
     * If you need to make 1 property required - use {@link ObjectSchemaBuilder.requiredFor}
     */
    required(): ObjectSchemaBuilder<Definition, Required<T>>;
    /**
     * Define schema for additional properties
     *
     * If you need to make `additionalProperties=false` use `strict` method instead
     *
     * @see {@link ObjectSchemaBuilder.strict strict}
     */
    rest<S extends AnySchemaBuilder>(def: S): ObjectSchemaBuilder<Definition & S, T & {
        [K in string]: Infer<S>;
    }, T & {
        [K in string]: Infer<S>;
    }>;
    /**
     * Merge current object with another object definition
     * @example
     * const a = s.object({num: s.number()})
     * const b = s.object({str: s.string()})
     * const c = a.merge(b)
     * type C = s.infer<typeof c> // {num: number; str: string}
     */
    merge<Def extends ObjectDefinition = ObjectDefinition, ObjSchema extends ObjectSchemaBuilder<Def> = ObjectSchemaBuilder<Def>>(schema: ObjSchema): ObjectSchemaBuilder<Merge<Definition, Def>, Merge<this["_output"], ObjSchema["_output"]>>;
    /**
     * Same as `merge`, but not accepts `s.object`.
     * @example
     * const a = s.object({num: s.number()})
     * const c = a.extend({str: s.string()})
     * type C = s.infer<typeof c> // {num: number; str: string}
     */
    extend<ObjDef extends ObjectDefinition = ObjectDefinition>(def: ObjDef): ObjectSchemaBuilder<Merge<Definition, ObjDef>>;
    /**
     * Mark object as `readOnly`. It mostly decoration for typescript.
     *
     * Set `schema.readOnly=true`.
     * @see {@link https://json-schema.org/draft-07/json-schema-validation#rfc.section.10.3 JSON-schema - readOnly keyword}
     */
    readonly(): ObjectSchemaBuilder<Definition, Readonly<T>>;
    /**
     * Inspired by TypeScript's built-in `Pick` and `Omit` utility types,
     * all object schemas have `.pick` and `.omit` methods that return a modified version.
     * Consider this Recipe schema:
     * @example
     * const Recipe = z.object({
     * id: z.string(),
     * name: z.string(),
     * ingredients: z.array(z.string()),
     * });
     * const JustTheNameAndId = Recipe.pick('name', 'id');
     * type JustTheName = s.infer<typeof JustTheNameAndId>;
     * // => { name: string, id: string }
     */
    pick<K extends keyof T, Keys extends K[] = K[]>(...keys: Keys): ObjectSchemaBuilder<Definition, Pick<T, Keys[number]>>;
    /**
     * Inspired by TypeScript's built-in `Pick` and `Omit` utility types,
     * all object schemas have `.pick` and `.omit` methods that return a modified version.
     * Consider this Recipe schema:
     * @example
     * const Recipe = s.object({
     * id: s.string(),
     * name: s.string(),
     * ingredients: s.array(s.string()),
     * });
     * const JustTheName = Recipe.omit('name');
     * type JustTheName = s.infer<typeof JustTheName>;
     * // => { id: string; ingredients: string[] }
     */
    omit<K extends keyof T, Keys extends K[] = K[]>(...keys: Keys): ObjectSchemaBuilder<Definition, Omit<T, Keys[number]>>;
    /**
     * Use `.keyof` to create a `EnumSchema` from the keys of an object schema.
     * @example
     * const Dog = z.object({
     *   name: z.string(),
     *   age: z.number(),
     * });
     * const keySchema = Dog.keyof();
     * keySchema; // Enum<["name", "age"]>
     */
    keyof<Key extends string | number = Exclude<keyof Definition, symbol>>(): EnumSchemaBuilder<{ [K in Extract<Key, string>]: K; }, Extract<Key, string>[]>;
}
/**
 * Create `object` schema.
 *
 * JSON schema: `{type: 'object', properties: {}}`
 *
 * You can pass you object type to get typescript validation
 * @example
 * import s from 'ajv-ts'
 * type User = {
 *   name: string;
 *   age: number;
 * };
 * const UserSchema = s.object<User>({}) // typescript error: expect type User, got {}
 */
declare function object<ObjType extends {
    [key: string]: string | number | boolean | null | undefined | readonly unknown[] | object;
} = {}, Definitions extends ObjectDefinition = {
    [K in keyof ObjType]: MatchTypeToBuilder<ObjType[K]> extends SchemaBuilder ? MatchTypeToBuilder<ObjType[K]> : never;
}>(def?: Definitions): ObjectSchemaBuilder<Definitions, { [K in keyof Definitions]: Infer<Definitions[K]>; }, Merge$1<((keyof Definitions extends infer T_2 ? T_2 extends keyof Definitions ? T_2 extends keyof Definitions ? undefined extends { [K in keyof Definitions]: Infer<Definitions[K]>; }[T_2] ? T_2 : never : never : never : never) extends infer T_1 extends keyof { [K in keyof Definitions]: Infer<Definitions[K]>; } ? { [K_2 in T_1]?: { [K in keyof Definitions]: Infer<Definitions[K]>; }[K_2] | undefined; } : never) & { [K_3 in Exclude<keyof Definitions, keyof Definitions extends infer T_2 ? T_2 extends keyof Definitions ? T_2 extends keyof Definitions ? undefined extends { [K in keyof Definitions]: Infer<Definitions[K]>; }[T_2] ? T_2 : never : never : never : never>]: { [K in keyof Definitions]: Infer<Definitions[K]>; }[K_3]; }> extends infer T ? { [K_1 in keyof T]: Merge$1<((keyof Definitions extends infer T_2 ? T_2 extends keyof Definitions ? T_2 extends keyof Definitions ? undefined extends { [K in keyof Definitions]: Infer<Definitions[K]>; }[T_2] ? T_2 : never : never : never : never) extends infer T_1 extends keyof { [K in keyof Definitions]: Infer<Definitions[K]>; } ? { [K_2 in T_1]?: { [K in keyof Definitions]: Infer<Definitions[K]>; }[K_2] | undefined; } : never) & { [K_3 in Exclude<keyof Definitions, keyof Definitions extends infer T_2 ? T_2 extends keyof Definitions ? T_2 extends keyof Definitions ? undefined extends { [K in keyof Definitions]: Infer<Definitions[K]>; }[T_2] ? T_2 : never : never : never : never>]: { [K in keyof Definitions]: Infer<Definitions[K]>; }[K_3]; }>[K_1]; } : never>;
declare class RecordSchemaBuilder<ValueDef extends AnySchemaBuilder = AnySchemaBuilder> extends SchemaBuilder<Record<string, Infer<ValueDef>>, ObjectSchema> {
    constructor(def?: ValueDef);
}
/**
 * Same as `object` but less strict for properties.
 *
 * Same as `object().passthrough()`
 * @see {@link object}
 */
declare function record<Def extends AnySchemaBuilder>(valueDef?: Def): RecordSchemaBuilder<Def>;
type ArrayShemaOpts = {
    minLength?: number;
    maxLength?: number;
    prefix?: any[];
};
type GetArrayOrEmpty<T> = T extends readonly unknown[] ? T : [];
declare class ArraySchemaBuilder<El = undefined, Arr extends readonly unknown[] = El[], S extends AnySchemaBuilder = SchemaBuilder<El, any, El>, Opts extends ArrayShemaOpts = {
    prefix: [];
    minLength: undefined;
    maxLength: undefined;
}> extends SchemaBuilder<Arr, ArraySchema, [...GetArrayOrEmpty<Opts['prefix']>, ...Arr]> {
    constructor(definition?: S);
    /**
     * Make your array `readonly`.
     *
     * Set in JSON schema `unevaluatedItems=false`.
     */
    readonly(): ArraySchemaBuilder<El, MakeReadonly<Arr>, S, Opts>;
    /**
     * set `prefixItems` in your schema.
     *
     * For better DX - we mark main element schema as `element`.
     */
    prefix<Pref extends AnySchemaBuilder[]>(...definitions: Pref): ArraySchemaBuilder<El, [element: El], S, {
        prefix: InferArray<Pref>;
        maxLength: Opts['maxLength'];
        minLength: Opts['minLength'];
    }>;
    /**
     * Append subschema for current array schema.
     *
     * If your schema contains 1 element - this method will transform to array.
     *
     * **NOTE:** if your schema defined with `items: false` - `boolean` value will be replaced to incoming schema.
     *
     * @example
     * import s from 'ajv-ts'
     * const arr = s
     *   .array(s.string()) // schema = { type: 'array', items: {type: 'string'} }
     *   .addItems(s.number(), s.boolean())
     * arr.schema // {type: 'array', items: [{type: 'string'}, {type: 'number'}, {type: 'boolean'}] }
     */
    addItems<Schema extends AnySchemaBuilder, Schemas extends SchemaBuilder[] = Schema[]>(...s: Schemas): ArraySchemaBuilder<El | Infer<Schema>, [
        ...Arr,
        ...InferArray<Schemas>
    ], S, Opts>;
    max: <const L extends number, Valid = IsPositiveInteger<L>, IsValidByMaxLength = Opts["minLength"] extends number ? GreaterThan<L, Opts["minLength"]> : true>(value: Valid extends false ? TTypeGenericError<`Only Positive and non floating numbers are supported. Received: '${L}'`> : IsValidByMaxLength extends false ? TRangeGenericError<"MaxLength less than MinLength", [`MinLength: ${Opts["minLength"]}`, `MaxLength: ${L}`]> : L) => ArraySchemaBuilder<El, Optional<Create<L, El>>, S, {
        maxLength: L;
        minLength: Opts["minLength"];
        prefix: Opts["prefix"];
    }>;
    /**
     * Must contain less items or equal than declared
     * @see {@link ArraySchemaBuilder.length length}
     * @see {@link ArraySchemaBuilder.minLength minLength}
     * @example
     * const arr = s.array(s.number()).maxLength(3)
     * arr.parse([1, 2, 3]) // OK
     * arr.parse([1]) // OK
     * arr.parse([1, 2, 3, 4]) // Error
     */
    maxLength<const L extends number, Valid = IsPositiveInteger<L>, IsValidByMaxLength = Opts['minLength'] extends number ? GreaterThan<L, Opts['minLength']> : true>(value: Valid extends false ? TTypeGenericError<`Only Positive and non floating numbers are supported. Received: '${L}'`> : IsValidByMaxLength extends false ? TRangeGenericError<'MaxLength less than MinLength', [
        `MinLength: ${Opts['minLength']}`,
        `MaxLength: ${L}`
    ]> : L): ArraySchemaBuilder<El, Optional<Create<L, El>>, S, {
        maxLength: L;
        minLength: Opts['minLength'];
        prefix: Opts['prefix'];
    }>;
    /**
   * Must contain more items or equal than declared
   *
   * @see {@link ArraySchemaBuilder.length length}
   * @see {@link ArraySchemaBuilder.maxLength maxLength}
   * @example
   * const arr = s.array(s.number()).minLength(3)
   * arr.parse([1, 2, 3]) // OK
   * arr.parse([1]) // Error
   * arr.parse([1, 2, 3, 4]) // OK
   */
    minLength<const L extends number, IsValidByMaxLength = Opts['maxLength'] extends undefined ? true : Opts['maxLength'] extends number ? LessThan<L, Opts['maxLength']> : true>(value: IsPositiveInteger<L> extends false ? TTypeGenericError<`MinLength should be positive integer. Received: '${L}'`, [L]> : IsValidByMaxLength extends false ? TRangeGenericError<`MaxLength is less than minLength.`, [
        `MinLength: ${L}`,
        `MaxLength: ${Opts['maxLength']}`
    ]> : L): ArraySchemaBuilder<El, [...Create<L, El>, ...El[]], S, {
        maxLength: Opts['maxLength'];
        minLength: L;
        prefix: Opts['prefix'];
    }>;
    min: <const L extends number, IsValidByMaxLength = Opts["maxLength"] extends undefined ? true : Opts["maxLength"] extends number ? LessThan<L, Opts["maxLength"]> : true>(value: IsPositiveInteger<L> extends false ? TTypeGenericError<`MinLength should be positive integer. Received: '${L}'`, [L]> : IsValidByMaxLength extends false ? TRangeGenericError<`MaxLength is less than minLength.`, [`MinLength: ${L}`, `MaxLength: ${Opts["maxLength"]}`]> : L) => ArraySchemaBuilder<El, [...Create<L, El>, ...El[]], S, {
        maxLength: Opts["maxLength"];
        minLength: L;
        prefix: Opts["prefix"];
    }>;
    /**
     * Returns schema builder of the element.
     *
     * If element is an array - returns `ArraySchemaBuilder` instance
     *
     * @example
     * import s from 'ajv-ts'
     * const strArr = s.array(s.string())
     * const str = strArr.element // isntance of StringSchemaBuilder
     * s.parse('qwe') // ok, string schema
     * s.schema // {type: 'string'}
     */
    get element(): El extends Array<unknown> ? ArraySchemaBuilder<El[number], El> : El extends string | number | boolean | object | unknown[] | null | undefined ? MatchTypeToBuilder<El> : SchemaBuilder<El>;
    /**
     * Must contain array length exactly. Same as `minLength(v).maxLength(v)`
     * @see {@link ArraySchemaBuilder.maxLength}
     * @see {@link ArraySchemaBuilder.minLength}
     * @example
     * const arr = s.array(s.number()).length(5)
     * arr.parse([1, 2, 3, 4, 5]) // OK
     * arr.parse([1, 2, 3, 4, 5, 6]) // Error
     * arr.parse([1, 2, 3, 4]) // Error
     */
    length<L extends number, Valid = IsPositiveInteger<L>, OkMinLength = Opts['minLength'] extends undefined ? true : false, OkMaxLength = Opts['maxLength'] extends undefined ? true : false>(value: OkMaxLength extends true ? OkMinLength extends true ? Valid extends true ? L : TTypeGenericError<`expected positive integer. Received: '${L}'`> : TRangeGenericError<`MinLength not equal to Length. MinLength: ${Opts['minLength']}. Length: ${L}`> : TRangeGenericError<`MaxLength not equal to Length. MaxLength: ${Opts['maxLength']}. Length: ${L}`>): ArraySchemaBuilder<El, Create<L, El>, S, Pick<Opts, 'prefix'> & {
        minLength: L;
        maxLength: L;
    }>;
    /**
     * same as `s.array().minLength(1)`
     * @see {@link ArraySchemaBuilder.minLength}
     */
    nonEmpty<HasLength = GreaterThan<Arr["length"], number>>(): ArraySchemaBuilder<El, HasLength extends true ? Arr : [El, ...El[]], S, {
        prefix: Opts['prefix'];
        minLength: 1;
        maxLength: Opts['maxLength'];
    }>;
    /**
     * Set the `uniqueItems` keyword to `true`.
     * @example
     * const items = s.array(s.number()).unique()
     *
     * items.parse([1, 2, 3, 4, 5]) // OK
     * items.parse([1, 2, 3, 3, 3]) // Error: items are not unique
     */
    unique(): this;
    /**
     * `contains` schema only needs to validate against one or more items in the array.
     *
     * JSON Schema: `{type: 'array', contains: <json-schema>}`
     * @example
     * const arr = s.array().contains(s.number())
     * arr.validate([]) // false, no numbers here
     * arr.validate([true, 1, 'str']) // true
     */
    contains<S extends AnySchemaBuilder>(containItem: S): this;
    /**
     * ## draft 2019-09
     * `minContains` and `maxContains` can be used with contains to further specify how many times a schema matches a
     * `contains` constraint. These keywords can be any non-negative number including zero.
     * @example
     * const schema = s.array(s.string()).contains(s.number()).minContains(3)
     * schema.parse(['qwe', 1,2,3]) // OK
     * schema.parse(['qwe', 1,2]) // Error, expect at least 3 numerics
     */
    minContains<const N extends number = number, Valid = IsPositiveInteger<N>>(value: Valid extends true ? N : [
        never,
        'TypeError: "minContains" should be positive integer',
        `Received: '${N}'`
    ]): this;
    /**
     * ## draft 2019-09
     * `minContains` and `maxContains` can be used with contains to further specify how many times a schema matches a
     * `contains` constraint. These keywords can be any non-negative number including zero.
     * @example
     * const schema = s.array(s.string()).contains(s.number()).maxContains(3)
     * schema.parse(['qwe', 1,2,3]) // OK
     * schema.parse(['qwe', 1,2,3, 4]) // Error, expect max 3 numbers
     */
    maxContains<const N extends number = number, Valid = IsPositiveInteger<N>>(value: Valid extends true ? N : [
        never,
        'TypeError: "maxContains" should be positive integer',
        `Received: '${N}'`
    ]): this;
}
/**
 * Define schema for array of elements. Accept array of subschemas.
 * @example
 * import s from 'ajv-ts'
 *
 * const tuple = s.array(s.string(), s.number())
 * tuple.schema // {type: 'array', items: [{type: 'string'}, {type: 'number'}] }
 */
declare function array<S extends AnySchemaBuilder = AnySchemaBuilder>(definition?: S): ArraySchemaBuilder<Infer<S>, Infer<S>[], S, {
    maxLength: undefined;
    minLength: undefined;
    prefix: [];
}>;
type AssertArray<T> = T extends any[] ? T : never;
type TupleItems = [AnySchemaBuilder, ...AnySchemaBuilder[]];
type OutputTypeOfTuple<T extends TupleItems | []> = AssertArray<{
    [k in keyof T]: T[k] extends SchemaBuilder<any, any, any> ? T[k]["_output"] : never;
}>;
type OutputTypeOfTupleWithRest<T extends TupleItems | [], Rest extends SchemaBuilder | null = null> = Rest extends SchemaBuilder ? [...OutputTypeOfTuple<T>, ...Infer<Rest>[]] : OutputTypeOfTuple<T>;
declare class TupleSchemaBuilder<Schemas extends TupleItems | [] = TupleItems> extends SchemaBuilder<OutputTypeOfTupleWithRest<Schemas>, ArraySchema> {
    constructor(...defs: Schemas);
    /** set `unevaluatedItems` to `false`. That means that all properties should be evaluated */
    required(): this;
}
/**
 * Similar to `array`, but it's tuple
 * @example
 * const athleteSchema = z.tuple([
 *  z.string(), // name
 *  z.number(), // jersey number
 *  z.object({
 *   pointsScored: z.number(),
 *  }), // statistics
 * ]);
 * type Athlete = z.infer<typeof athleteSchema>;
 * // type Athlete = [string, number, { pointsScored: number }]
 */
declare function tuple<Defs extends TupleItems | [] = TupleItems | []>(defs: Defs): TupleSchemaBuilder<[...Defs]>;
declare class EnumSchemaBuilder<Enum extends EnumLike = EnumLike, Tuple extends Enum[keyof Enum][] = Enum[keyof Enum][]> extends SchemaBuilder<Tuple, EnumAnnotation, Tuple[number]> {
    private _enum;
    readonly options: Tuple;
    constructor(values: Tuple);
    /**
     * returns enum as object representation
     */
    get enum(): Enum;
}
type EnumLike = {
    [k: string]: string | number;
    [nu: number]: string;
};
/**
 * handle `enum` typescript type to make `enum` JSON annotation
 */
declare function makeEnum<E extends EnumLike = EnumLike>(enumLike: E): EnumSchemaBuilder<E, E[keyof E][]>;
/**
 * handle tuple(array) of possible values to make `enum` JSON annotation
 */
declare function makeEnum<P extends string | number = string | number, T extends P[] | readonly P[] = [], U extends UnionToTuple<T[number]> = UnionToTuple<T[number]>>(possibleValues: T): EnumSchemaBuilder<{
    [K in Extract<T[number], string>]: K;
}, Extract<T[number], string>[]>;
declare class ConstantSchemaBuilder<T extends number | string | boolean | null | object = never> extends SchemaBuilder<T, ConstantAnnotation> {
    readonly value: T;
    constructor(value: T);
}
/**
 * `const` is used to restrict a value to a single value.
 *
 * zod differences - `Date` is supported.
 * @alias literal
 * @satisfies zod API. **NOTE:** `Symbol`, unserializable `object` is not supported and throws error.
 * @example
 * const constant = s.const("Hello World")
 * constant.validate("Hello World") // true
 * constant.validate("Hello World 1") // false
 */
declare function constant<T extends number | string | boolean | null | object>(value: T): ConstantSchemaBuilder<T>;
declare class UnionSchemaBuilder<S extends AnySchemaBuilder[] = AnySchemaBuilder[]> extends SchemaBuilder<Infer<S[number]>, AnySchemaOrAnnotation> {
    constructor(...schemas: S);
}
declare function or<S extends AnySchemaBuilder[] = SchemaBuilder[]>(...defs: S): UnionSchemaBuilder<S>;
declare class IntersectionSchemaBuilder<S extends AnySchemaBuilder[] = SchemaBuilder[], Elem extends AnySchemaBuilder = S[number], Intersection extends AnySchemaBuilder = UnionToIntersection<Elem> extends SchemaBuilder ? UnionToIntersection<Elem> : SchemaBuilder> extends SchemaBuilder<Infer<Elem>, AnySchemaOrAnnotation, Infer<Intersection>> {
    constructor(...schemas: S);
}
declare function and<S extends AnySchemaBuilder[] = SchemaBuilder[]>(...defs: S): IntersectionSchemaBuilder<S, S[number], UnionToIntersection<S[number]> extends SchemaBuilder<unknown, AnySchemaOrAnnotation, unknown, {
    _preProcesses: [];
    _postProcesses: [];
}> ? SchemaBuilder<unknown, AnySchemaOrAnnotation, unknown, {
    _preProcesses: [];
    _postProcesses: [];
}> & UnionToIntersection<S[number]> : SchemaBuilder<unknown, AnySchemaOrAnnotation, unknown, {
    _preProcesses: [];
    _postProcesses: [];
}>>;
type PropKey = Exclude<PropertyKey, symbol>;
/**
 * Extract keys from given schema `s.object` and set as constant for output schema
 *
 * TypeScript - `keyof T` type
 *
 * JSON schema - `{anyOf: [{const: 'key1'}, {const: 'key2'}, ...] }`
 * @throws `Error` if given schema doesn't have `properties` properties. Only non-empty `object` schema has `properties` properties.
 */
declare function keyof<ObjSchema extends ObjectSchemaBuilder, Res extends PropKey = keyof ObjSchema["_output"] extends PropKey ? keyof ObjSchema["_output"] : never>(obj: ObjSchema): UnionSchemaBuilder<ConstantSchemaBuilder<Res>[]>;
declare class UnknownSchemaBuilder<T extends unknown | any> extends SchemaBuilder<T, any> {
    constructor();
}
/**
 * TypeScript - `any` type
 *
 * JSON schema - `{}` (empty object)
 */
declare function any(): SchemaBuilder<any, any>;
/**
 * Same as {@link any} but for typescript better type quality.
 *
 * TypeScript - `unknown` type
 *
 * JSON schema - `{}` (empty object)
 */
declare function unknown(): UnknownSchemaBuilder<unknown>;
declare class NeverSchemaBuilder extends SchemaBuilder<never> {
    constructor();
}
/**
 * Typescript - `never` type.
 *
 * JSON Schema - `{ not: {} }`
 */
declare function never(): NeverSchemaBuilder;
declare class NotSchemaBuilder<S extends AnySchemaBuilder = SchemaBuilder<any, any, any>, T extends number | string | boolean | object | null | Array<unknown> = number | string | boolean | object | null | Array<unknown>, Out = Exclude<T, S["_output"]>> extends SchemaBuilder<S["_output"], AnySchemaOrAnnotation, Out> {
    constructor(schema: S);
}
/**
 * The `not` declares that an instance validates if it doesn't validate against the given subschema.
 *
 * **NOTE:** `s.not(s.string())` and `s.string().not()` is not the same!
 *
 * JSON Schema: `{ not: <json schema> }`
 *
 * @see {@link https://json-schema.org/understanding-json-schema/reference/combining#not json schema `not` keyword}
 * @see {@link SchemaBuilder.not not method}
 * @example
 * import s from 'ajv-ts'
 *
 * const notString = s.not(s.string())
 * // or
 * const notStringAlternative = s.string().not()
 *
 * notString.parse(42) // OK
 * notString.parse({key: 'value'}) // OK
 * notString.parse('I am a string') // throws
 */
declare function not<S extends AnySchemaBuilder = AnySchemaBuilder>(def: S): NotSchemaBuilder<S, string | number | boolean | object | unknown[] | null, Exclude<null, S["_output"]> | Exclude<string, S["_output"]> | Exclude<number, S["_output"]> | Exclude<false, S["_output"]> | Exclude<true, S["_output"]> | Exclude<object, S["_output"]> | Exclude<unknown[], S["_output"]>>;
/**
 * get JSON-schema from somewhere and merge with `baseSchema`
 * @param externalJsonSchema external schema. E.g. from swagger
 * @param [baseSchema=any() as S] schema to use. Default is `s.any()`.
 * @example
 * const v = s.fromJSON({someCustomProp: true}, s.string())
 * v.schema.someCustomProp === true
 * v.schema.type === 'string'
 */
declare function fromJSON<const T, S extends AnySchemaBuilder>(externalJsonSchema: T, baseSchema?: S): S;
/**
 * Create new instance of schema definition with non default AJV instance
 *
 * @example
 * import Ajv from 'ajv'
 * import s from 'ajv-ts'
 *
 * const myAjv = new Ajv(/custom options/);
 * const builder = s.create(myAjv)
 *
 * builder.number().parse(123) // OK, but use myAjv instance instead of default
 */
declare function create(ajv: Ajv): {
    number: typeof number;
    integer: typeof integer;
    int: typeof integer;
    string: typeof string;
    null: typeof nil;
    enum: typeof makeEnum;
    nativeEnum: typeof makeEnum;
    boolean: typeof boolean;
    object: typeof object;
    keyof: typeof keyof;
    record: typeof record;
    array: typeof array;
    tuple: typeof tuple;
    const: typeof constant;
    literal: typeof constant;
    unknown: typeof unknown;
    any: typeof any;
    never: typeof never;
    or: typeof or;
    union: typeof or;
    and: typeof and;
    intersection: typeof and;
    not: typeof not;
    fromJSON: typeof fromJSON;
};

/**
 * Extract schema level defenition and return it's represenation as typescript type
 */
type Infer<T extends SchemaBuilder<any, any, any, any>> = T["_output"];
/** Extract SchemaBuilder[] - used in array schema to build right types */
type InferArray<T extends SchemaBuilder[], Result extends unknown[] = []> = T extends [] ? unknown[] : T extends [
    infer First extends SchemaBuilder,
    ...infer Rest extends SchemaBuilder[]
] ? Rest extends [] ? [...Result, Infer<First>] : InferArray<Rest, [...Result, Infer<First>]> : T extends Array<infer El extends SchemaBuilder> ? [...Result, ...Infer<El>[]] : Result;
/** extract schema input type */
type Input<T extends SchemaBuilder<any, any, any, any>> = T["_input"];
type MatchTypeToBuilder<T> = T extends boolean ? BooleanSchemaBuilder<T> : T extends Array<infer El extends number | string | object | boolean | null> ? ArraySchemaBuilder<MatchTypeToBuilder<El>[]> : T extends string ? StringSchemaBuilder<T> : T extends number ? NumberSchemaBuilder<T> : T extends Record<string, number | boolean | string | object | unknown[] | null> ? {
    [K in keyof T]: MatchTypeToBuilder<T[K]>;
} : T extends null ? NullSchemaBuilder : T extends undefined ? SchemaBuilder<T | undefined, any, T | undefined> : T extends unknown ? UnknownSchemaBuilder<T> : T extends SchemaBuilder<any, any, infer Out> ? SchemaBuilder<any, any, Out> : SchemaBuilder<any, any, any>;

type s_AnySchemaBuilder = AnySchemaBuilder;
type s_ArrayShemaOpts = ArrayShemaOpts;
declare const s_DEFAULT_AJV: typeof DEFAULT_AJV;
type s_ErrorMessageParams<T extends AnySchemaBuilder> = ErrorMessageParams<T>;
type s_Infer<T extends SchemaBuilder<any, any, any, any>> = Infer<T>;
type s_InferArray<T extends SchemaBuilder[], Result extends unknown[] = []> = InferArray<T, Result>;
type s_Input<T extends SchemaBuilder<any, any, any, any>> = Input<T>;
type s_MatchTypeToBuilder<T> = MatchTypeToBuilder<T>;
type s_MetaObject = MetaObject;
type s_ObjectDefinition = ObjectDefinition;
type s_SafeParseErrorResult<T> = SafeParseErrorResult<T>;
type s_SafeParseResult<T> = SafeParseResult<T>;
type s_SafeParseSuccessResult<T> = SafeParseSuccessResult<T>;
type s_SchemaBuilder<Input = unknown, Schema extends AnySchemaOrAnnotation = AnySchemaOrAnnotation, Output = Input, Opts extends SchemaBuilderOpts = {
    _preProcesses: [];
    _postProcesses: [];
}> = SchemaBuilder<Input, Schema, Output, Opts>;
declare const s_SchemaBuilder: typeof SchemaBuilder;
type s_SchemaBuilderOpts = SchemaBuilderOpts;
type s_StringBuilderOpts = StringBuilderOpts;
declare const s_and: typeof and;
declare const s_any: typeof any;
declare const s_array: typeof array;
declare const s_boolean: typeof boolean;
declare const s_create: typeof create;
declare const s_fromJSON: typeof fromJSON;
declare const s_integer: typeof integer;
declare const s_keyof: typeof keyof;
declare const s_never: typeof never;
declare const s_not: typeof not;
declare const s_number: typeof number;
declare const s_object: typeof object;
declare const s_or: typeof or;
declare const s_record: typeof record;
declare const s_string: typeof string;
declare const s_tuple: typeof tuple;
declare const s_unknown: typeof unknown;
declare namespace s {
  export { DEFAULT_AJV as Ajv, IntersectionSchemaBuilder as And, type AnySchemaBuilder as Any, type s_AnySchemaBuilder as AnySchemaBuilder, ArraySchemaBuilder as Array, type s_ArrayShemaOpts as ArrayShemaOpts, BooleanSchemaBuilder as Boolean, s_DEFAULT_AJV as DEFAULT_AJV, type s_ErrorMessageParams as ErrorMessageParams, type s_Infer as Infer, type s_InferArray as InferArray, type s_Input as Input, type s_MatchTypeToBuilder as MatchTypeToBuilder, type s_MetaObject as MetaObject, NeverSchemaBuilder as Never, NullSchemaBuilder as Null, NumberSchemaBuilder as Number, ObjectSchemaBuilder as Object, type s_ObjectDefinition as ObjectDefinition, UnionSchemaBuilder as Or, type s_SafeParseErrorResult as SafeParseErrorResult, type s_SafeParseResult as SafeParseResult, type s_SafeParseSuccessResult as SafeParseSuccessResult, s_SchemaBuilder as SchemaBuilder, type s_SchemaBuilderOpts as SchemaBuilderOpts, StringSchemaBuilder as String, type s_StringBuilderOpts as StringBuilderOpts, UnknownSchemaBuilder as Unknown, s_and as and, s_any as any, s_array as array, s_boolean as boolean, constant as const, s_create as create, makeEnum as enum, s_fromJSON as fromJSON, type Infer as infer, type Input as input, integer as int, s_integer as integer, and as intersection, s_keyof as keyof, constant as literal, makeEnum as nativeEnum, s_never as never, create as new, s_not as not, nil as null, s_number as number, s_object as object, s_or as or, s_record as record, s_string as string, s_tuple as tuple, or as union, s_unknown as unknown };
}

export { DEFAULT_AJV as Ajv, IntersectionSchemaBuilder as And, type AnySchemaBuilder as Any, type AnySchemaBuilder, ArraySchemaBuilder as Array, type ArrayShemaOpts, BooleanSchemaBuilder as Boolean, DEFAULT_AJV, type ErrorMessageParams, type Infer, type InferArray, type Input, type MatchTypeToBuilder, type MetaObject, NeverSchemaBuilder as Never, NullSchemaBuilder as Null, NumberSchemaBuilder as Number, ObjectSchemaBuilder as Object, type ObjectDefinition, UnionSchemaBuilder as Or, type SafeParseErrorResult, type SafeParseResult, type SafeParseSuccessResult, SchemaBuilder, type SchemaBuilderOpts, types as SchemaType, StringSchemaBuilder as String, type StringBuilderOpts, UnknownSchemaBuilder as Unknown, and, any, array, boolean, constant as const, create, s as default, makeEnum as enum, fromJSON, type Infer as infer, type Input as input, integer as int, integer, and as intersection, keyof, constant as literal, makeEnum as nativeEnum, never, create as new, not, nil as null, number, object, or, record, s, string, tuple, or as union, unknown };
