function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { ContentType, Status } from "allure-js-commons";
import { getMessageAndTraceFromError, getStatusFromError, getUnfinishedStepsMessages, isPromise } from "allure-js-commons/sdk";
import { getGlobalTestRuntime, setGlobalTestRuntime } from "allure-js-commons/sdk/runtime";
import { ALLURE_REPORT_STEP_COMMAND } from "./model.js";
import { dropCurrentTest, enqueueRuntimeMessage, getCurrentTest, getRuntimeMessages, setCurrentTest, setRuntimeMessages } from "./state.js";
import { getSuites, getTestSkipData, getTestStartData, getTestStopData, isAllureHook, isTestReported, iterateTests, markTestAsReported, uint8ArrayToBase64 } from "./utils.js";
var _resetMessages = /*#__PURE__*/new WeakMap();
var _enqueueMessageAsync = /*#__PURE__*/new WeakMap();
var _dequeueAllMessages = /*#__PURE__*/new WeakMap();
export class AllureCypressTestRuntime {
  constructor() {
    _defineProperty(this, "flushAllureMessagesToTask", taskName => {
      var messages = _classPrivateFieldGet(_dequeueAllMessages, this).call(this);
      if (messages.length) {
        cy.task(taskName, {
          absolutePath: Cypress.spec.absolute,
          messages
        }, {
          log: false
        });
      }
    });
    _defineProperty(this, "flushAllureMessagesToTaskAsync", taskName => {
      var messages = _classPrivateFieldGet(_dequeueAllMessages, this).call(this);
      if (messages.length) {
        var args = {
          absolutePath: Cypress.spec.absolute,
          messages,
          isInteractive: Cypress.config("isInteractive")
        };
        return cy.task(taskName, args, {
          log: false
        });
      }
    });
    _classPrivateFieldInitSpec(this, _resetMessages, () => setRuntimeMessages([]));
    _classPrivateFieldInitSpec(this, _enqueueMessageAsync, message => {
      enqueueRuntimeMessage(message);
      return Cypress.Promise.resolve();
    });
    _classPrivateFieldInitSpec(this, _dequeueAllMessages, () => {
      var messages = getRuntimeMessages();
      _classPrivateFieldGet(_resetMessages, this).call(this);
      return messages;
    });
    _classPrivateFieldGet(_resetMessages, this).call(this);
  }
  labels() {
    for (var _len = arguments.length, labels = new Array(_len), _key = 0; _key < _len; _key++) {
      labels[_key] = arguments[_key];
    }
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "metadata",
      data: {
        labels
      }
    });
  }
  links() {
    for (var _len2 = arguments.length, links = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      links[_key2] = arguments[_key2];
    }
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "metadata",
      data: {
        links
      }
    });
  }
  parameter(name, value, options) {
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "metadata",
      data: {
        parameters: [_objectSpread({
          name,
          value
        }, options)]
      }
    });
  }
  description(markdown) {
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "metadata",
      data: {
        description: markdown
      }
    });
  }
  descriptionHtml(html) {
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "metadata",
      data: {
        descriptionHtml: html
      }
    });
  }
  displayName(name) {
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "metadata",
      data: {
        displayName: name
      }
    });
  }
  historyId(value) {
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "metadata",
      data: {
        historyId: value
      }
    });
  }
  testCaseId(value) {
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "metadata",
      data: {
        testCaseId: value
      }
    });
  }

  // @ts-ignore
  attachment(name, content, options) {
    // @ts-ignore
    var attachmentRawContent = (content === null || content === void 0 ? void 0 : content.type) === "Buffer" ? content.data : content;
    var actualEncoding = typeof attachmentRawContent === "string" ? "utf8" : "base64";
    var attachmentContent = uint8ArrayToBase64(attachmentRawContent);
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "attachment_content",
      data: {
        name,
        content: attachmentContent,
        encoding: actualEncoding,
        contentType: options.contentType,
        fileExtension: options.fileExtension
      }
    });
  }
  attachmentFromPath(name, path, options) {
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "attachment_path",
      data: {
        name,
        path,
        contentType: options.contentType,
        fileExtension: options.fileExtension
      }
    });
  }
  logStep(name) {
    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Status.PASSED;
    var error = arguments.length > 2 ? arguments[2] : undefined;
    return cy.wrap(ALLURE_REPORT_STEP_COMMAND, {
      log: false
    }).then(() => {
      _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
        type: "step_start",
        data: {
          name,
          start: Date.now()
        }
      });
      return Cypress.Promise.resolve();
    }).then(() => {
      return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
        type: "step_stop",
        data: {
          status: status,
          stop: Date.now(),
          statusDetails: error ? _objectSpread({}, getMessageAndTraceFromError(error)) : undefined
        }
      });
    });
  }
  step(name, body) {
    return cy.wrap(ALLURE_REPORT_STEP_COMMAND, {
      log: false
    }).then(() => {
      _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
        type: "step_start",
        data: {
          name,
          start: Date.now()
        }
      });
      return Cypress.Promise.resolve(body());
    }).then(result => {
      return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
        type: "step_stop",
        data: {
          status: Status.PASSED,
          stop: Date.now()
        }
      }).then(() => result);
    });
  }
  stepDisplayName(name) {
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "step_metadata",
      data: {
        name
      }
    });
  }
  stepParameter(name, value, mode) {
    return _classPrivateFieldGet(_enqueueMessageAsync, this).call(this, {
      type: "step_metadata",
      data: {
        parameters: [{
          name,
          value,
          mode
        }]
      }
    });
  }
}
export var initTestRuntime = () => setGlobalTestRuntime(new AllureCypressTestRuntime());
export var getTestRuntime = () => getGlobalTestRuntime();
export var reportRunStart = () => {
  enqueueRuntimeMessage({
    type: "cypress_run_start",
    data: {}
  });
};
export var reportSuiteStart = suite => {
  enqueueRuntimeMessage({
    type: "cypress_suite_start",
    data: {
      id: suite.id,
      name: suite.title,
      root: suite.root,
      start: Date.now()
    }
  });
};
export var reportSuiteEnd = suite => {
  enqueueRuntimeMessage({
    type: "cypress_suite_end",
    data: {
      root: suite.root,
      stop: Date.now()
    }
  });
};
export var reportHookStart = (hook, start) => {
  enqueueRuntimeMessage({
    type: "cypress_hook_start",
    data: {
      name: hook.title,
      scopeType: hook.hookName.includes("each") ? "each" : "all",
      position: hook.hookName.includes("before") ? "before" : "after",
      start: start !== null && start !== void 0 ? start : Date.now()
    }
  });
};
export var reportHookEnd = hook => {
  var _hook$duration;
  enqueueRuntimeMessage({
    type: "cypress_hook_end",
    data: {
      duration: (_hook$duration = hook.duration) !== null && _hook$duration !== void 0 ? _hook$duration : 0
    }
  });
};
export var reportTestStart = test => {
  setCurrentTest(test);
  enqueueRuntimeMessage({
    type: "cypress_test_start",
    data: getTestStartData(test)
  });
  markTestAsReported(test);
};
export var reportUnfinishedSteps = (status, statusDetails) => {
  var runtimeMessages = getRuntimeMessages();
  var unfinishedStepsMessages = getUnfinishedStepsMessages(runtimeMessages);
  unfinishedStepsMessages.forEach(() => {
    enqueueRuntimeMessage({
      type: "step_stop",
      data: {
        stop: Date.now(),
        status,
        statusDetails
      }
    });
  });
};
export var reportTestPass = () => {
  reportUnfinishedSteps(Status.PASSED);
  enqueueRuntimeMessage({
    type: "cypress_test_pass",
    data: {}
  });
};
export var reportTestSkip = test => {
  if (isTestReported(test)) {
    reportUnfinishedCommand(Status.SKIPPED, {
      message: "The test was skipped before the command was completed"
    });
  } else {
    reportTestStart(test);
  }
  enqueueRuntimeMessage({
    type: "cypress_test_skip",
    data: getTestSkipData()
  });
};
export var reportCommandStart = command => {
  enqueueRuntimeMessage({
    type: "cypress_command_start",
    data: {
      name: "Command \"".concat(command.attributes.name, "\""),
      args: command.attributes.args.map(arg => typeof arg === "string" ? arg : JSON.stringify(arg, null, 2)),
      start: Date.now()
    }
  });
};
export var reportCommandEnd = () => {
  enqueueRuntimeMessage({
    type: "cypress_command_end",
    data: {
      status: Status.PASSED,
      stop: Date.now()
    }
  });
};
export var reportScreenshot = (path, name) => {
  enqueueRuntimeMessage({
    type: "attachment_path",
    data: {
      path: path,
      name: name || "Screenshot",
      contentType: ContentType.PNG
    }
  });
};
export var reportUnfinishedCommand = (status, statusDetails) => {
  var runtimeMessages = getRuntimeMessages();
  var startCommandMessageIdx = runtimeMessages.toReversed().findIndex(_ref => {
    var {
      type
    } = _ref;
    return type === "cypress_command_start";
  });
  var stopCommandMessageIdx = runtimeMessages.toReversed().findIndex(_ref2 => {
    var {
      type
    } = _ref2;
    return type === "cypress_command_end";
  });
  var hasUnfinishedCommand = startCommandMessageIdx > stopCommandMessageIdx;
  var data = {
    status,
    stop: Date.now()
  };
  if (statusDetails) {
    data.statusDetails = statusDetails;
  }
  if (hasUnfinishedCommand) {
    enqueueRuntimeMessage({
      type: "cypress_command_end",
      data
    });
  }
};
export var reportTestOrHookFail = err => {
  var status = getStatusFromError(err);
  var statusDetails = getMessageAndTraceFromError(err);
  reportUnfinishedCommand(status, statusDetails);
  enqueueRuntimeMessage({
    type: "cypress_fail",
    data: {
      status,
      statusDetails
    }
  });
};
export var reportTestEnd = test => {
  var _test$duration, _retries;
  enqueueRuntimeMessage({
    type: "cypress_test_end",
    data: {
      duration: (_test$duration = test.duration) !== null && _test$duration !== void 0 ? _test$duration : 0,
      retries: (_retries = test._retries) !== null && _retries !== void 0 ? _retries : 0
    }
  });
  dropCurrentTest();
};
export var completeHookErrorReporting = (hook, err) => {
  var isEachHook = hook.hookName.includes("each");
  var suite = hook.parent;
  var testFailData = getStatusDataOfTestSkippedByHookError(hook.title, isEachHook, err, suite);

  // Cypress doens't emit 'hook end' if the hook has failed.
  reportHookEnd(hook);

  // Cypress doens't emit 'test end' if the hook has failed.
  // We must report the test's end manualy in case of a 'before each' hook.
  reportCurrentTestIfAny();

  // Cypress skips the remaining tests in the suite of a failed hook.
  // We should include them to the report manually.
  reportRemainingTests(suite, testFailData);
};

/**
 * Patches the `after` function, to inject an extra `after` hook after each spec-level
 * `after` hook defined by the user.
 */
export var enableScopeLevelAfterHookReporting = () => {
  var [getSuiteDepth, incSuiteDepth, decSuiteDepth] = createSuiteDepthCounterState();
  patchDescribe(incSuiteDepth, decSuiteDepth);
  patchAfter(getSuiteDepth);
};
export var flushRuntimeMessages = () => getTestRuntime().flushAllureMessagesToTask("reportAllureCypressSpecMessages");
export var completeSpec = () => getTestRuntime().flushAllureMessagesToTaskAsync("reportFinalAllureCypressSpecMessages");
export var completeSpecIfNoAfterHookLeft = context => {
  if (isLastRootAfterHook(context)) {
    var hook = context.test;
    if (!isAllureHook(hook)) {
      reportHookEnd(hook);
    }
    return completeSpec();
  }
};
var completeSpecOnAfterHookFailure = (context, hookError) => {
  try {
    reportTestOrHookFail(hookError);
    completeHookErrorReporting(context.test, hookError);

    // cy.task's then doesn't have onrejected, that's why we don't log async Allure errors here.
    return completeSpec();
  } catch (allureError) {
    logAllureRootAfterError(context, allureError);
  }
};
var reportCurrentTestIfAny = () => {
  var currentTest = getCurrentTest();
  if (currentTest) {
    reportTestEnd(currentTest);
  }
};
var reportRemainingTests = (suite, testFailData) => {
  for (var test of iterateTests(suite)) {
    // Some tests in the suite might've been already reported.
    if (!isTestReported(test)) {
      reportTestsSkippedByHookError(test, test.pending ? _objectSpread(_objectSpread({}, getTestSkipData()), {}, {
        status: Status.SKIPPED
      }) : testFailData);
    }
  }
};
var reportTestsSkippedByHookError = (test, testFailData) => {
  enqueueRuntimeMessage({
    type: "cypress_skipped_test",
    data: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, getTestStartData(test)), testFailData), getTestStopData(test)), {}, {
      suites: getSuites(test).map(s => s.id)
    })
  });
  markTestAsReported(test);
};
var getStatusDataOfTestSkippedByHookError = (hookTitle, isEachHook, err, suite) => {
  var status = isEachHook ? Status.SKIPPED : getStatusFromError(err);
  var {
    message,
    trace
  } = getMessageAndTraceFromError(err);
  return {
    status,
    statusDetails: {
      message: isEachHook ? getSkipReason(hookTitle, suite) : message,
      trace
    }
  };
};
var getSkipReason = (hookTitle, suite) => {
  var suiteName = suite.title ? "'".concat(suite.title, "'") : "root";
  return "'".concat(hookTitle, "' defined in the ").concat(suiteName, " suite has failed");
};
var forwardDescribeCall = function forwardDescribeCall(target) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  var [title, configOrFn, fn] = args;
  if (typeof fn === "undefined" && typeof configOrFn === "undefined") {
    return target(title);
  } else if (typeof configOrFn === "function") {
    return target(title, configOrFn);
  } else {
    return target(title, configOrFn, fn);
  }
};
var patchDescribe = (incSuiteDepth, decSuiteDepth) => {
  var patchDescribeFn = target => (title, configOrFn, fn) => {
    incSuiteDepth();
    try {
      return forwardDescribeCall(target, title, configOrFn, fn);
    } finally {
      decSuiteDepth();
    }
  };
  var originalDescribeFn = globalThis.describe;
  var patchedDescribe = patchDescribeFn(originalDescribeFn);
  patchedDescribe.only = patchDescribeFn(originalDescribeFn.only);
  patchedDescribe.skip = patchDescribeFn(originalDescribeFn.skip);
  globalThis.describe = patchedDescribe;
};
var createSuiteDepthCounterState = () => {
  var suiteDepth = 0;
  return [() => suiteDepth, () => {
    suiteDepth++;
  }, () => {
    suiteDepth--;
  }];
};
var patchAfter = getSuiteDepth => {
  var originalAfter = globalThis.after;
  var patchedAfter = (nameOrFn, fn) => {
    return typeof nameOrFn === "string" ? originalAfter(nameOrFn, wrapRootAfterFn(getSuiteDepth, fn)) : originalAfter(wrapRootAfterFn(getSuiteDepth, nameOrFn));
  };
  globalThis.after = patchedAfter;
};
var wrapRootAfterFn = (getSuiteDepth, fn) => {
  if (getSuiteDepth() === 0 && fn) {
    var wrappedFn = fn.length ? wrapAfterFnWithCallback(fn) : wrapAfterFnWithoutArgs(fn);
    Object.defineProperty(wrappedFn, "name", {
      value: fn.name
    });
    return wrappedFn;
  }
  return fn;
};
var wrapAfterFnWithCallback = fn => {
  return function (done) {
    var wrappedDone = hookError => {
      if (hookError) {
        var _completeSpecOnAfterH;
        if (!((_completeSpecOnAfterH = completeSpecOnAfterHookFailure(this, hookError)) !== null && _completeSpecOnAfterH !== void 0 && _completeSpecOnAfterH.then(() => done(hookError)))) {
          done(hookError);
        }
        return;
      }
      try {
        var _completeSpecIfNoAfte;
        if ((_completeSpecIfNoAfte = completeSpecIfNoAfterHookLeft(this)) !== null && _completeSpecIfNoAfte !== void 0 && _completeSpecIfNoAfte.then(() => done())) {
          return;
        }
      } catch (allureError) {
        done(allureError);
        return;
      }
      done();
    };
    return fn.bind(this)(wrappedDone);
  };
};
var wrapAfterFnWithoutArgs = fn => {
  return function () {
    var result;
    var syncError;
    try {
      result = fn.bind(this)();
    } catch (e) {
      syncError = e;
    }
    if (syncError) {
      throwAfterSpecCompletion(this, syncError);
    } else if (isPromise(result)) {
      return result.then(() => completeSpecIfNoAfterHookLeft(this), asyncError => throwAfterSpecCompletion(this, asyncError));
    } else {
      completeSpecIfNoAfterHookLeft(this);
      return result;
    }
  };
};
var throwAfterSpecCompletion = (context, err) => {
  var _completeSpecOnAfterH2;
  var chain = (_completeSpecOnAfterH2 = completeSpecOnAfterHookFailure(context, err)) === null || _completeSpecOnAfterH2 === void 0 ? void 0 : _completeSpecOnAfterH2.then(() => {
    throw err;
  });
  if (!chain) {
    throw err;
  }
};
var logAllureRootAfterError = (context, err) => {
  // We play safe and swallow errors here to keep the original 'after all' error.
  try {
    var _context$test$title, _context$test;
    // eslint-disable-next-line no-console
    console.error("Unexpected error when reporting the failure of ".concat((_context$test$title = (_context$test = context.test) === null || _context$test === void 0 ? void 0 : _context$test.title) !== null && _context$test$title !== void 0 ? _context$test$title : "'after all'"));
    // eslint-disable-next-line no-console
    console.error(err);
  } catch (_unused) {}
};
var isLastRootAfterHook = context => {
  var currentAfterAll = context.test;
  var rootSuite = context.test.parent;
  var hooks = rootSuite.hooks;
  var lastAfterAll = hooks.findLast(h => h.hookName === "after all");
  return (lastAfterAll === null || lastAfterAll === void 0 ? void 0 : lastAfterAll.hookId) === currentAfterAll.hookId;
};
//# sourceMappingURL=runtime.js.map