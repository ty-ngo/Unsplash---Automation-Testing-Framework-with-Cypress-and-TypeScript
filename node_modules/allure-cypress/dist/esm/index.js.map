{
  "version": 3,
  "sources": ["../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/model.ts", "../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/sdk/utils.ts", "../../src/model.ts", "../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/sdk/runtime/NoopTestRuntime.ts", "../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/sdk/runtime/runtime.ts", "../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/facade.ts", "../../src/state.ts", "../../src/utils.ts", "../../src/runtime.ts", "../../src/index.ts"],
  "sourcesContent": ["export interface Attachment {\n  name: string;\n  type?: string;\n  source: string;\n}\n\nexport interface AttachmentOptions {\n  contentType: ContentType | string;\n  encoding?: BufferEncoding;\n  fileExtension?: string;\n}\n\nexport interface Label {\n  name: LabelName | string;\n  value: string;\n}\n\nexport interface Link {\n  name?: string;\n  url: string;\n  type?: LinkType | string;\n}\n\nexport type ParameterMode = \"hidden\" | \"masked\" | \"default\";\n\nexport interface Parameter {\n  name: string;\n  value: string;\n  excluded?: boolean;\n  mode?: ParameterMode;\n}\n\nexport type ParameterOptions = Pick<Parameter, \"mode\" | \"excluded\">;\n\nexport interface StatusDetails {\n  message?: string;\n  trace?: string;\n}\n\n// don't use the interface as is, use Results types instead\ninterface Executable {\n  name?: string;\n  status?: Status;\n  statusDetails: StatusDetails;\n  stage: Stage;\n  description?: string;\n  descriptionHtml?: string;\n  steps: StepResult[];\n  attachments: Attachment[];\n  parameters: Parameter[];\n  start?: number;\n  stop?: number;\n}\n\nexport interface FixtureResult extends Executable {}\n\nexport interface StepResult extends Executable {}\n\nexport interface TestResult extends Executable {\n  uuid: string;\n  historyId?: string;\n  fullName?: string;\n  testCaseId?: string;\n  labels: Label[];\n  links: Link[];\n}\n\nexport interface TestResultContainer {\n  uuid: string;\n  name?: string;\n  children: string[];\n  befores: FixtureResult[];\n  afters: FixtureResult[];\n}\n\nexport type TestOrStepResult = StepResult | TestResult;\n\n/* eslint-disable no-shadow */\nexport enum Status {\n  FAILED = \"failed\",\n  BROKEN = \"broken\",\n  PASSED = \"passed\",\n  SKIPPED = \"skipped\",\n}\n\nexport const StatusByPriority = [Status.FAILED, Status.BROKEN, Status.PASSED, Status.SKIPPED];\n\n/* eslint-disable no-shadow */\nexport enum Stage {\n  SCHEDULED = \"scheduled\",\n  RUNNING = \"running\",\n  FINISHED = \"finished\",\n  PENDING = \"pending\",\n  INTERRUPTED = \"interrupted\",\n}\n\n/* eslint-disable no-shadow */\nexport enum LabelName {\n  ALLURE_ID = \"ALLURE_ID\",\n  /**\n   * @deprecated please use ALLURE_ID instead\n   */\n  AS_ID = ALLURE_ID,\n  SUITE = \"suite\",\n  PARENT_SUITE = \"parentSuite\",\n  SUB_SUITE = \"subSuite\",\n  EPIC = \"epic\",\n  FEATURE = \"feature\",\n  STORY = \"story\",\n  SEVERITY = \"severity\",\n  TAG = \"tag\",\n  OWNER = \"owner\",\n  LEAD = \"lead\",\n  HOST = \"host\",\n  THREAD = \"thread\",\n  TEST_METHOD = \"testMethod\",\n  TEST_CLASS = \"testClass\",\n  PACKAGE = \"package\",\n  FRAMEWORK = \"framework\",\n  LANGUAGE = \"language\",\n  LAYER = \"layer\",\n}\n\n/* eslint-disable no-shadow */\nexport enum Severity {\n  BLOCKER = \"blocker\",\n  CRITICAL = \"critical\",\n  NORMAL = \"normal\",\n  MINOR = \"minor\",\n  TRIVIAL = \"trivial\",\n}\n\n/* eslint-disable no-shadow */\nexport enum ContentType {\n  TEXT = \"text/plain\",\n  XML = \"application/xml\",\n  HTML = \"text/html\",\n  CSV = \"text/csv\",\n  TSV = \"text/tab-separated-values\",\n  CSS = \"text/css\",\n  URI = \"text/uri-list\",\n  SVG = \"image/svg+xml\",\n  PNG = \"image/png\",\n  JSON = \"application/json\",\n  ZIP = \"application/zip\",\n  WEBM = \"video/webm\",\n  JPEG = \"image/jpeg\",\n  MP4 = \"video/mp4\",\n  IMAGEDIFF = \"application/vnd.allure.image.diff\",\n}\n\n/* eslint-disable no-shadow */\nexport enum LinkType {\n  DEFAULT = \"link\",\n  ISSUE = \"issue\",\n  TMS = \"tms\",\n}\n\nexport interface ImageDiffAttachment {\n  expected: string | undefined; // data:image;base64,\n  actual: string | undefined; // data:image;base64,\n  diff: string | undefined; // data:image;base64,\n  name: string;\n}\n", "import type { FixtureResult, Label, StatusDetails, StepResult, TestResult } from \"../model.js\";\nimport { LabelName, Status } from \"../model.js\";\nimport type { RuntimeMessage } from \"./types.js\";\n\nexport const getStatusFromError = (error: Error): Status => {\n  switch (true) {\n    /**\n     * Native `node:assert` and `chai` (`vitest` uses it under the hood) throw `AssertionError`\n     * `jest` throws `JestAssertionError` instance\n     * `jasmine` throws `ExpectationFailed` instance\n     * `vitest` throws `Error` for extended assertions, so we look into stack\n     */\n    case /assert/gi.test(error.constructor.name):\n    case /expectation/gi.test(error.constructor.name):\n    case /assert/gi.test(error.name):\n    case /assert/gi.test(error.message):\n    case error.stack && /@vitest\\/expect/gi.test(error.stack):\n      return Status.FAILED;\n    default:\n      return Status.BROKEN;\n  }\n};\n\n/**\n * Source: https://github.com/chalk/ansi-regex\n */\nconst ansiRegex = ({ onlyFirst = false } = {}) => {\n  const pattern = [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))\",\n  ].join(\"|\");\n\n  return new RegExp(pattern, onlyFirst ? undefined : \"g\");\n};\n\n/**\n * https://github.com/chalk/strip-ansi\n */\nexport const stripAnsi = (str: string): string => {\n  const regex = ansiRegex();\n  return str.replace(regex, \"\");\n};\n\nexport const getMessageAndTraceFromError = (\n  error: Error | { message?: string; stack?: string },\n): Pick<StatusDetails, \"message\" | \"trace\"> => {\n  const { message, stack } = error;\n  return {\n    message: message ? stripAnsi(message) : undefined,\n    trace: stack ? stripAnsi(stack) : undefined,\n  };\n};\n\nexport const allureIdRegexp = /(?:^|\\s)@?allure\\.id[:=](?<id>[^\\s]+)/;\nexport const allureIdRegexpGlobal = new RegExp(allureIdRegexp, \"g\");\nexport const allureLabelRegexp = /(?:^|\\s)@?allure\\.label\\.(?<name>[^:=\\s]+)[:=](?<value>[^\\s]+)/;\nexport const allureLabelRegexpGlobal = new RegExp(allureLabelRegexp, \"g\");\n\nexport const isMetadataTag = (tag: string) => {\n  return allureIdRegexp.test(tag) || allureLabelRegexp.test(tag);\n};\n\nexport const extractMetadataFromString = (\n  title: string,\n): {\n  labels: Label[];\n  cleanTitle: string;\n} => {\n  const labels = [] as Label[];\n\n  title.split(\" \").forEach((val) => {\n    const idValue = val.match(allureIdRegexp)?.groups?.id;\n\n    if (idValue) {\n      labels.push({ name: LabelName.ALLURE_ID, value: idValue });\n    }\n\n    const labelMatch = val.match(allureLabelRegexp);\n    const { name, value } = labelMatch?.groups || {};\n\n    if (name && value) {\n      labels?.push({ name, value });\n    }\n  });\n\n  const cleanTitle = title.replace(allureLabelRegexpGlobal, \"\").replace(allureIdRegexpGlobal, \"\").trim();\n\n  return { labels, cleanTitle };\n};\n\nexport const isAnyStepFailed = (item: StepResult | TestResult | FixtureResult): boolean => {\n  const isFailed = item.status === Status.FAILED;\n\n  if (isFailed || item.steps.length === 0) {\n    return isFailed;\n  }\n\n  return !!item.steps.find((step) => isAnyStepFailed(step));\n};\n\nexport const isAllStepsEnded = (item: StepResult | TestResult | FixtureResult): boolean => {\n  return item.steps.every((val) => val.stop && isAllStepsEnded(val));\n};\n\nexport const hasLabel = (testResult: TestResult, labelName: LabelName | string): boolean => {\n  return !!testResult.labels.find((l) => l.name === labelName);\n};\n\nexport const hasStepMessage = (messages: RuntimeMessage[]) => {\n  return messages.some((message) => message.type === \"step_start\" || message.type === \"step_stop\");\n};\n\nexport const getStepsMessagesPair = (messages: RuntimeMessage[]) =>\n  messages.reduce((acc, message) => {\n    if (message.type !== \"step_start\" && message.type !== \"step_stop\") {\n      return acc;\n    }\n\n    if (message.type === \"step_start\") {\n      acc.push([message]);\n\n      return acc;\n    }\n\n    const unfinishedStepIdx = acc.findLastIndex((step) => step.length === 1);\n\n    if (unfinishedStepIdx === -1) {\n      return acc;\n    }\n\n    acc[unfinishedStepIdx].push(message);\n\n    return acc;\n  }, [] as RuntimeMessage[][]);\n\nexport const getUnfinishedStepsMessages = (messages: RuntimeMessage[]) => {\n  const grouppedStepsMessage = getStepsMessagesPair(messages);\n\n  return grouppedStepsMessage.filter((step) => step.length === 1);\n};\n\nexport const isPromise = <T = any>(obj: any): obj is PromiseLike<T> =>\n  !!obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof obj.then === \"function\";\n", "import type { Label, Status, StatusDetails } from \"allure-js-commons\";\nimport type { RuntimeMessage, TestPlanV1 } from \"allure-js-commons/sdk\";\nimport type { ReporterConfig } from \"allure-js-commons/sdk/reporter\";\n\nexport const ALLURE_REPORT_SYSTEM_HOOK = \"__allure_report_system_hook__\";\n\nexport const ALLURE_REPORT_STEP_COMMAND = \"__allure_report_step_command__\";\n\nexport type AllureCypressConfig = ReporterConfig & {\n  videoOnFailOnly?: boolean;\n};\n\nexport type CypressSuite = Mocha.Suite & {\n  id: string;\n  parent: CypressSuite | undefined;\n  tests: CypressTest[];\n  suites: CypressSuite[];\n};\n\nexport type CypressTest = Mocha.Test & {\n  wallClockStartedAt?: Date;\n  parent: CypressSuite | undefined;\n};\n\nexport type CypressHook = Mocha.Hook & {\n  hookId: string;\n  hookName: string;\n  parent: CypressSuite | undefined;\n};\n\nexport type CypressCommand = {\n  attributes: {\n    name: string;\n    id: string;\n    args: any[];\n  };\n  state: \"passed\" | \"failed\" | \"queued\";\n};\n\nexport type CupressRunStart = {\n  type: \"cypress_run_start\";\n  data: object;\n};\n\nexport type CypressSuiteStartMessage = {\n  type: \"cypress_suite_start\";\n  data: {\n    id: string;\n    name: string;\n    root: boolean;\n    start: number;\n  };\n};\n\nexport type CypressSuiteEndMessage = {\n  type: \"cypress_suite_end\";\n  data: {\n    root: boolean;\n    stop: number;\n  };\n};\n\nexport type CypressHookStartMessage = {\n  type: \"cypress_hook_start\";\n  data: {\n    name: string;\n    scopeType: \"each\" | \"all\";\n    position: \"before\" | \"after\";\n    start: number;\n  };\n};\n\nexport type CypressHookEndMessage = {\n  type: \"cypress_hook_end\";\n  data: {\n    duration: number;\n  };\n};\n\nexport type CypressTestStartMessage = {\n  type: \"cypress_test_start\";\n  data: {\n    name: string;\n    fullName: string;\n    start: number;\n    labels: Label[];\n  };\n};\n\nexport type CypressFailMessage = {\n  type: \"cypress_fail\";\n  data: {\n    status: Status;\n    statusDetails: StatusDetails;\n  };\n};\n\nexport type CypressTestSkipMessage = {\n  type: \"cypress_test_skip\";\n  data: {\n    statusDetails?: StatusDetails;\n  };\n};\n\nexport type CypressTestPassMessage = {\n  type: \"cypress_test_pass\";\n  data: object;\n};\n\nexport type CypressSkippedTestMessage = {\n  type: \"cypress_skipped_test\";\n  data: CypressTestStartMessage[\"data\"] &\n    CypressFailMessage[\"data\"] &\n    CypressTestEndMessage[\"data\"] & {\n      suites: string[];\n    };\n};\n\nexport type CypressTestEndMessage = {\n  type: \"cypress_test_end\";\n  data: {\n    duration: number;\n    retries: number;\n  };\n};\n\nexport type CypressCommandStartMessage = {\n  type: \"cypress_command_start\";\n  data: {\n    name: string;\n    args: string[];\n    start: number;\n  };\n};\n\nexport type CypressCommandEndMessage = {\n  type: \"cypress_command_end\";\n  data: {\n    status: Status;\n    statusDetails?: StatusDetails;\n    stop: number;\n  };\n};\n\nexport type CypressMessage =\n  | RuntimeMessage\n  | CupressRunStart\n  | CypressSuiteStartMessage\n  | CypressSuiteEndMessage\n  | CypressHookStartMessage\n  | CypressHookEndMessage\n  | CypressTestStartMessage\n  | CypressCommandStartMessage\n  | CypressCommandEndMessage\n  | CypressTestPassMessage\n  | CypressFailMessage\n  | CypressTestSkipMessage\n  | CypressSkippedTestMessage\n  | CypressTestEndMessage;\n\nexport type SpecContext = {\n  specPath: string;\n  package: string;\n  test: string | undefined;\n  fixture: string | undefined;\n  commandSteps: string[];\n  videoScope: string;\n  suiteIdToScope: Map<string, string>;\n  suiteScopeToId: Map<string, string>;\n  suiteScopes: string[];\n  testScope: string | undefined;\n  suiteNames: string[];\n  failed: boolean;\n};\n\nexport type AllureSpecState = {\n  initialized: boolean;\n  testPlan: TestPlanV1 | null | undefined;\n  messages: CypressMessage[];\n  currentTest?: CypressTest;\n};\n\nexport type AllureCypressTaskArgs = {\n  absolutePath: string;\n  messages: readonly CypressMessage[];\n  isInteractive: boolean;\n};\n\nexport type CypressSuiteFunction = (\n  title: string,\n  configOrFn?: Cypress.SuiteConfigOverrides | ((this: Mocha.Suite) => void),\n  fn?: (this: Mocha.Suite) => void,\n) => Mocha.Suite;\n\nexport type DirectHookImplementation = Mocha.AsyncFunc | ((this: Mocha.Context) => void);\nexport type HookImplementation = Mocha.Func | DirectHookImplementation;\n", "import type { TestRuntime } from \"./types.js\";\n\nexport class NoopTestRuntime implements TestRuntime {\n  async attachment() {\n    await this.warning();\n  }\n\n  async attachmentFromPath() {\n    await this.warning();\n  }\n\n  async description() {\n    await this.warning();\n  }\n\n  async descriptionHtml() {\n    await this.warning();\n  }\n\n  async displayName() {\n    await this.warning();\n  }\n\n  async historyId() {\n    await this.warning();\n  }\n\n  async labels() {\n    await this.warning();\n  }\n\n  async links() {\n    await this.warning();\n  }\n\n  async parameter() {\n    await this.warning();\n  }\n\n  async logStep() {\n    await this.warning();\n  }\n\n  async step<T>(name: string, body: () => T | PromiseLike<T>): Promise<T> {\n    await this.warning();\n    return body();\n  }\n\n  async stepDisplayName() {\n    await this.warning();\n  }\n\n  async stepParameter() {\n    await this.warning();\n  }\n\n  async testCaseId() {\n    await this.warning();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async warning() {\n    // eslint-disable-next-line no-console\n    console.log(\"no test runtime is found. Please check test framework configuration\");\n  }\n}\n\nexport const noopRuntime: TestRuntime = new NoopTestRuntime();\n", "import { noopRuntime } from \"./NoopTestRuntime.js\";\nimport type { TestRuntime } from \"./types.js\";\n\nconst ALLURE_TEST_RUNTIME_KEY = \"allureTestRuntime\";\n\nexport const setGlobalTestRuntime = (runtime: TestRuntime) => {\n  (globalThis as any)[ALLURE_TEST_RUNTIME_KEY] = () => runtime;\n};\n\nconst getGlobalTestRuntimeFunction = () => {\n  return (globalThis as any)?.[ALLURE_TEST_RUNTIME_KEY] as (() => TestRuntime | undefined) | undefined;\n};\n\nexport const getGlobalTestRuntime = (): TestRuntime => {\n  const testRuntime = getGlobalTestRuntimeFunction();\n\n  if (testRuntime) {\n    return testRuntime() ?? noopRuntime;\n  }\n\n  return noopRuntime;\n};\n\nexport const getGlobalTestRuntimeWithAutoconfig = (): TestRuntime | Promise<TestRuntime> => {\n  const testRuntime = getGlobalTestRuntimeFunction();\n\n  if (testRuntime) {\n    return testRuntime() ?? noopRuntime;\n  }\n\n  if (\"_playwrightInstance\" in globalThis) {\n    try {\n      // protection from bundlers tree-shaking visiting (webpack, rollup)\n      // @ts-ignore\n      // eslint-disable-next-line no-eval\n      return (0, eval)(\"(() => import('allure-playwright/autoconfig'))()\").then(() => {\n        return getGlobalTestRuntimeFunction()?.() ?? noopRuntime;\n      });\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.log(\"can't execute allure-playwright/autoconfig\", err);\n      return noopRuntime;\n    }\n  }\n\n  return noopRuntime;\n};\n", "import type { Status } from \"./model.js\";\nimport { type ContentType } from \"./model.js\";\nimport { type AttachmentOptions, type Label, type Link, type ParameterMode, type ParameterOptions } from \"./model.js\";\nimport { LabelName, LinkType } from \"./model.js\";\nimport { getGlobalTestRuntimeWithAutoconfig } from \"./sdk/runtime/runtime.js\";\nimport type { TestRuntime } from \"./sdk/runtime/types.js\";\nimport { isPromise } from \"./sdk/utils.js\";\n\nconst callRuntimeMethod = <\n  T extends keyof TestRuntime,\n  S extends Parameters<TestRuntime[T]>,\n  R extends ReturnType<TestRuntime[T]>,\n>(\n  method: T,\n  ...args: S\n): R => {\n  const runtime = getGlobalTestRuntimeWithAutoconfig();\n\n  if (!isPromise(runtime)) {\n    // @ts-ignore\n    return runtime[method](...args);\n  }\n\n  return runtime.then((testRuntime) => {\n    // @ts-ignore\n    return testRuntime[method](...args);\n  }) as R;\n};\n\nexport const label = (name: LabelName | string, value: string) => {\n  return callRuntimeMethod(\"labels\", { name, value });\n};\n\nexport const labels = (...labelsList: Label[]) => {\n  return callRuntimeMethod(\"labels\", ...labelsList);\n};\n\nexport const link = (url: string, name?: string, type?: LinkType | string) => {\n  return callRuntimeMethod(\"links\", { url, type, name });\n};\n\nexport const links = (...linksList: Link[]) => {\n  return callRuntimeMethod(\"links\", ...linksList);\n};\n\nexport const parameter = (name: string, value: string, options?: ParameterOptions) => {\n  return callRuntimeMethod(\"parameter\", name, value, options);\n};\n\nexport const description = (markdown: string) => {\n  return callRuntimeMethod(\"description\", markdown);\n};\n\nexport const descriptionHtml = (html: string) => {\n  return callRuntimeMethod(\"descriptionHtml\", html);\n};\n\nexport const displayName = (name: string) => {\n  return callRuntimeMethod(\"displayName\", name);\n};\n\nexport const historyId = (value: string) => {\n  return callRuntimeMethod(\"historyId\", value);\n};\n\nexport const testCaseId = (value: string) => {\n  return callRuntimeMethod(\"testCaseId\", value);\n};\n\nexport const attachment = (\n  name: string,\n  content: Buffer | string,\n  options: ContentType | string | AttachmentOptions,\n) => {\n  const opts = typeof options === \"string\" ? { contentType: options } : options;\n  return callRuntimeMethod(\"attachment\", name, content, opts);\n};\n\nexport const attachmentPath = (\n  name: string,\n  path: string,\n  options: ContentType | string | Omit<AttachmentOptions, \"encoding\">,\n) => {\n  const opts = typeof options === \"string\" ? { contentType: options } : options;\n  return callRuntimeMethod(\"attachmentFromPath\", name, path, opts);\n};\n\nexport type StepContext = {\n  displayName: (name: string) => void | PromiseLike<void>;\n  parameter: (name: string, value: string, mode?: ParameterMode) => void | PromiseLike<void>;\n};\n\nconst stepContext: () => StepContext = () => ({\n  displayName: (name: string) => {\n    return callRuntimeMethod(\"stepDisplayName\", name);\n  },\n  parameter: (name, value, mode?) => {\n    return callRuntimeMethod(\"stepParameter\", name, value, mode);\n  },\n});\n\nexport const logStep = (name: string, status?: Status, error?: Error): PromiseLike<void> => {\n  return callRuntimeMethod(\"logStep\", name, status, error);\n};\n\nexport const step = <T = void>(name: string, body: (context: StepContext) => T | PromiseLike<T>): PromiseLike<T> => {\n  return callRuntimeMethod(\"step\", name, () => body(stepContext()));\n};\n\nexport const issue = (url: string, name?: string) => link(url, name, LinkType.ISSUE);\n\nexport const tms = (url: string, name?: string) => link(url, name, LinkType.TMS);\n\nexport const allureId = (value: string) => label(LabelName.ALLURE_ID, value);\n\nexport const epic = (name: string) => label(LabelName.EPIC, name);\n\nexport const feature = (name: string) => label(LabelName.FEATURE, name);\n\nexport const story = (name: string) => label(LabelName.STORY, name);\n\nexport const suite = (name: string) => label(LabelName.SUITE, name);\n\nexport const parentSuite = (name: string) => label(LabelName.PARENT_SUITE, name);\n\nexport const subSuite = (name: string) => label(LabelName.SUB_SUITE, name);\n\nexport const owner = (name: string) => label(LabelName.OWNER, name);\n\nexport const severity = (name: string) => label(LabelName.SEVERITY, name);\n\nexport const layer = (name: string) => label(LabelName.LAYER, name);\n\nexport const tag = (name: string) => label(LabelName.TAG, name);\n\nexport const tags = (...tagsList: string[]) => {\n  return callRuntimeMethod(\"labels\", ...tagsList.map((value) => ({ name: LabelName.TAG, value })));\n};\n", "import type { AllureSpecState, CypressMessage, CypressTest } from \"./model.js\";\n\nexport const getAllureState = () => {\n  let state = Cypress.env(\"allure\") as AllureSpecState;\n  if (!state) {\n    state = {\n      initialized: false,\n      messages: [],\n      testPlan: undefined,\n      currentTest: undefined,\n    };\n    Cypress.env(\"allure\", state);\n  }\n  return state;\n};\n\nexport const isAllureInitialized = () => getAllureState().initialized;\n\nexport const setAllureInitialized = () => {\n  getAllureState().initialized = true;\n};\n\nexport const getRuntimeMessages = () => getAllureState().messages;\n\nexport const setRuntimeMessages = (value: CypressMessage[]) => {\n  getAllureState().messages = value;\n};\n\nexport const enqueueRuntimeMessage = (message: CypressMessage) => {\n  getRuntimeMessages().push(message);\n};\n\nexport const getAllureTestPlan = () => getAllureState().testPlan;\n\nexport const getCurrentTest = () => getAllureState().currentTest;\n\nexport const setCurrentTest = (test: CypressTest) => {\n  getAllureState().currentTest = test;\n};\n\nexport const dropCurrentTest = () => {\n  getAllureState().currentTest = undefined;\n};\n", "import { LabelName, Status } from \"allure-js-commons\";\nimport { extractMetadataFromString, getMessageAndTraceFromError, getStatusFromError } from \"allure-js-commons/sdk\";\nimport type { TestPlanV1 } from \"allure-js-commons/sdk\";\nimport { ALLURE_REPORT_STEP_COMMAND, ALLURE_REPORT_SYSTEM_HOOK } from \"./model.js\";\nimport type { CypressCommand, CypressHook, CypressSuite, CypressTest } from \"./model.js\";\nimport { getAllureTestPlan } from \"./state.js\";\n\nexport const uint8ArrayToBase64 = (data: unknown) => {\n  // @ts-ignore\n  const u8arrayLike = Array.isArray(data) || data.buffer;\n\n  if (!u8arrayLike) {\n    return data as string;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  return btoa(String.fromCharCode.apply(null, data as number[]));\n};\n\nexport const getSuites = (test: CypressTest) => {\n  const suites: CypressSuite[] = [];\n  for (let s: CypressSuite | undefined = test.parent; s; s = s.parent) {\n    suites.push(s);\n  }\n  suites.reverse();\n  return suites;\n};\n\nexport const getSuitePath = (test: CypressTest): string[] =>\n  getSuites(test)\n    .filter((s) => s.title)\n    .map((s) => s.title);\n\nexport const shouldCommandBeSkipped = (command: CypressCommand) => {\n  if (last(command.attributes.args)?.log === false) {\n    return true;\n  }\n\n  if (command.attributes.name === \"task\" && command.attributes.args[0] === \"reportAllureRuntimeMessages\") {\n    return true;\n  }\n\n  // we don't need to report then commands because it's just a promise handle\n  if (command.attributes.name === \"then\") {\n    return true;\n  }\n\n  // we should skip artificial wrap from allure steps\n  if (command.attributes.name === \"wrap\" && command.attributes.args[0] === ALLURE_REPORT_STEP_COMMAND) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const toReversed = <T = unknown>(arr: T[]): T[] => {\n  const result: T[] = [];\n\n  for (let i = arr.length - 1; i >= 0; i--) {\n    result.push(arr[i]);\n  }\n\n  return result;\n};\n\nexport const last = <T = unknown>(arr: T[]): T | undefined => {\n  return arr[arr.length - 1];\n};\n\nexport const getNamesAndLabels = (spec: Cypress.Spec, test: CypressTest) => {\n  const rawName = test.title;\n  const { cleanTitle: name, labels } = extractMetadataFromString(rawName);\n  const suites = test.titlePath().slice(0, -1);\n  const fullName = `${spec.relative}#${[...suites, name].join(\" \")}`;\n  return { name, labels, fullName };\n};\n\nexport const getTestStartData = (test: CypressTest) => ({\n  ...getNamesAndLabels(Cypress.spec, test),\n  start: test.wallClockStartedAt?.getTime() || Date.now(),\n});\n\nexport const getTestStopData = (test: CypressTest) => ({\n  duration: test.duration ?? 0,\n  retries: (test as any)._retries ?? 0,\n});\n\nexport const getTestSkipData = () => ({\n  statusDetails: { message: \"This is a pending test\" },\n});\n\nexport const applyTestPlan = (spec: Cypress.Spec, root: CypressSuite) => {\n  const testPlan = getAllureTestPlan();\n  if (testPlan) {\n    for (const suite of iterateSuites(root)) {\n      const indicesToRemove = getIndicesOfDeselectedTests(testPlan, spec, suite.tests);\n      removeSortedIndices(suite.tests, indicesToRemove);\n    }\n  }\n};\n\nexport const resolveStatusWithDetails = (error: Error | undefined) =>\n  error\n    ? {\n        status: getStatusFromError(error),\n        statusDetails: getMessageAndTraceFromError(error),\n      }\n    : { status: Status.PASSED };\n\nconst testReportedKey = Symbol(\"The test was reported to Allure\");\n\nexport const markTestAsReported = (test: CypressTest) => {\n  (test as any)[testReportedKey] = true;\n};\n\nexport const isTestReported = (test: CypressTest) => (test as any)[testReportedKey] === true;\n\nexport const iterateSuites = function* (parent: CypressSuite) {\n  const suiteStack: CypressSuite[] = [];\n  for (let s: CypressSuite | undefined = parent; s; s = suiteStack.pop()) {\n    yield s;\n\n    // Pushing in reverse allows us to maintain depth-first pre-order traversal -\n    // the same order as used by Mocha & Cypress.\n    for (let i = s.suites.length - 1; i >= 0; i--) {\n      suiteStack.push(s.suites[i]);\n    }\n  }\n};\n\nexport const iterateTests = function* (parent: CypressSuite) {\n  for (const suite of iterateSuites(parent)) {\n    yield* suite.tests;\n  }\n};\n\nexport const isAllureHook = (hook: CypressHook) => hook.title.includes(ALLURE_REPORT_SYSTEM_HOOK);\n\nexport const isRootAfterAllHook = (hook: CypressHook) => hook.parent!.root && hook.hookName === \"after all\";\n\nconst includedInTestPlan = (testPlan: TestPlanV1, fullName: string, allureId: string | undefined): boolean =>\n  testPlan.tests.some((test) => (allureId && test.id?.toString() === allureId) || test.selector === fullName);\n\nconst getIndicesOfDeselectedTests = (testPlan: TestPlanV1, spec: Cypress.Spec, tests: readonly CypressTest[]) => {\n  const indicesToRemove: number[] = [];\n  tests.forEach((test, index) => {\n    const { fullName, labels } = getNamesAndLabels(spec, test);\n    const allureId = labels.find(({ name }) => name === LabelName.ALLURE_ID)?.value;\n\n    if (!includedInTestPlan(testPlan, fullName, allureId)) {\n      indicesToRemove.push(index);\n    }\n  });\n  return indicesToRemove;\n};\n\nconst removeSortedIndices = <T>(arr: T[], indices: readonly number[]) => {\n  for (let i = indices.length - 1; i >= 0; i--) {\n    arr.splice(indices[i], 1);\n  }\n};\n", "import { ContentType, Status } from \"allure-js-commons\";\nimport type { AttachmentOptions, Label, Link, ParameterMode, ParameterOptions, StatusDetails } from \"allure-js-commons\";\nimport {\n  getMessageAndTraceFromError,\n  getStatusFromError,\n  getUnfinishedStepsMessages,\n  isPromise,\n} from \"allure-js-commons/sdk\";\nimport type { RuntimeMessage } from \"allure-js-commons/sdk\";\nimport { getGlobalTestRuntime, setGlobalTestRuntime } from \"allure-js-commons/sdk/runtime\";\nimport type { TestRuntime } from \"allure-js-commons/sdk/runtime\";\nimport type {\n  AllureCypressTaskArgs,\n  CypressCommand,\n  CypressCommandEndMessage,\n  CypressFailMessage,\n  CypressHook,\n  CypressMessage,\n  CypressSuite,\n  CypressSuiteFunction,\n  CypressTest,\n  DirectHookImplementation,\n  HookImplementation,\n} from \"./model.js\";\nimport { ALLURE_REPORT_STEP_COMMAND } from \"./model.js\";\nimport {\n  dropCurrentTest,\n  enqueueRuntimeMessage,\n  getCurrentTest,\n  getRuntimeMessages,\n  setCurrentTest,\n  setRuntimeMessages,\n} from \"./state.js\";\nimport {\n  getSuites,\n  getTestSkipData,\n  getTestStartData,\n  getTestStopData,\n  isAllureHook,\n  isTestReported,\n  iterateTests,\n  markTestAsReported,\n  uint8ArrayToBase64,\n} from \"./utils.js\";\n\nexport class AllureCypressTestRuntime implements TestRuntime {\n  constructor() {\n    this.#resetMessages();\n  }\n\n  labels(...labels: Label[]) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        labels,\n      },\n    });\n  }\n\n  links(...links: Link[]) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        links,\n      },\n    });\n  }\n\n  parameter(name: string, value: string, options?: ParameterOptions) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        parameters: [\n          {\n            name,\n            value,\n            ...options,\n          },\n        ],\n      },\n    });\n  }\n\n  description(markdown: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        description: markdown,\n      },\n    });\n  }\n\n  descriptionHtml(html: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        descriptionHtml: html,\n      },\n    });\n  }\n\n  displayName(name: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        displayName: name,\n      },\n    });\n  }\n\n  historyId(value: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        historyId: value,\n      },\n    });\n  }\n\n  testCaseId(value: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        testCaseId: value,\n      },\n    });\n  }\n\n  // @ts-ignore\n  attachment(name: string, content: string, options: AttachmentOptions) {\n    // @ts-ignore\n    const attachmentRawContent: string | Uint8Array = content?.type === \"Buffer\" ? content.data : content;\n    const actualEncoding = typeof attachmentRawContent === \"string\" ? \"utf8\" : \"base64\";\n    const attachmentContent = uint8ArrayToBase64(attachmentRawContent);\n\n    return this.#enqueueMessageAsync({\n      type: \"attachment_content\",\n      data: {\n        name,\n        content: attachmentContent,\n        encoding: actualEncoding,\n        contentType: options.contentType,\n        fileExtension: options.fileExtension,\n      },\n    });\n  }\n\n  attachmentFromPath(name: string, path: string, options: Omit<AttachmentOptions, \"encoding\">) {\n    return this.#enqueueMessageAsync({\n      type: \"attachment_path\",\n      data: {\n        name,\n        path,\n        contentType: options.contentType,\n        fileExtension: options.fileExtension,\n      },\n    });\n  }\n\n  logStep(name: string, status: Status = Status.PASSED, error?: Error) {\n    return cy\n      .wrap(ALLURE_REPORT_STEP_COMMAND, { log: false })\n      .then(() => {\n        this.#enqueueMessageAsync({\n          type: \"step_start\",\n          data: {\n            name,\n            start: Date.now(),\n          },\n        });\n\n        return Cypress.Promise.resolve();\n      })\n      .then(() => {\n        return this.#enqueueMessageAsync({\n          type: \"step_stop\",\n          data: {\n            status: status,\n            stop: Date.now(),\n            statusDetails: error ? { ...getMessageAndTraceFromError(error) } : undefined,\n          },\n        });\n      });\n  }\n\n  step<T = void>(name: string, body: () => T | PromiseLike<T>) {\n    return cy\n      .wrap(ALLURE_REPORT_STEP_COMMAND, { log: false })\n      .then(() => {\n        this.#enqueueMessageAsync({\n          type: \"step_start\",\n          data: {\n            name,\n            start: Date.now(),\n          },\n        });\n\n        return Cypress.Promise.resolve(body());\n      })\n      .then((result) => {\n        return this.#enqueueMessageAsync({\n          type: \"step_stop\",\n          data: {\n            status: Status.PASSED,\n            stop: Date.now(),\n          },\n        }).then(() => result);\n      });\n  }\n\n  stepDisplayName(name: string) {\n    return this.#enqueueMessageAsync({\n      type: \"step_metadata\",\n      data: {\n        name,\n      },\n    });\n  }\n\n  stepParameter(name: string, value: string, mode?: ParameterMode) {\n    return this.#enqueueMessageAsync({\n      type: \"step_metadata\",\n      data: {\n        parameters: [{ name, value, mode }],\n      },\n    });\n  }\n\n  flushAllureMessagesToTask = (taskName: string) => {\n    const messages = this.#dequeueAllMessages();\n    if (messages.length) {\n      cy.task(taskName, { absolutePath: Cypress.spec.absolute, messages }, { log: false });\n    }\n  };\n\n  flushAllureMessagesToTaskAsync = (taskName: string): Cypress.Chainable<unknown> | undefined => {\n    const messages = this.#dequeueAllMessages();\n    if (messages.length) {\n      const args: AllureCypressTaskArgs = {\n        absolutePath: Cypress.spec.absolute,\n        messages,\n        isInteractive: Cypress.config(\"isInteractive\"),\n      };\n      return cy.task(taskName, args, { log: false });\n    }\n  };\n\n  #resetMessages = () => setRuntimeMessages([]);\n\n  #enqueueMessageAsync = (message: CypressMessage): PromiseLike<void> => {\n    enqueueRuntimeMessage(message);\n    return Cypress.Promise.resolve();\n  };\n\n  #dequeueAllMessages = () => {\n    const messages = getRuntimeMessages();\n    this.#resetMessages();\n    return messages;\n  };\n}\n\nexport const initTestRuntime = () => setGlobalTestRuntime(new AllureCypressTestRuntime() as TestRuntime);\n\nexport const getTestRuntime = () => getGlobalTestRuntime() as AllureCypressTestRuntime;\n\nexport const reportRunStart = () => {\n  enqueueRuntimeMessage({\n    type: \"cypress_run_start\",\n    data: {},\n  });\n};\n\nexport const reportSuiteStart = (suite: CypressSuite) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_suite_start\",\n    data: {\n      id: suite.id,\n      name: suite.title,\n      root: suite.root,\n      start: Date.now(),\n    },\n  });\n};\n\nexport const reportSuiteEnd = (suite: CypressSuite) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_suite_end\",\n    data: {\n      root: suite.root,\n      stop: Date.now(),\n    },\n  });\n};\n\nexport const reportHookStart = (hook: CypressHook, start?: number) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_hook_start\",\n    data: {\n      name: hook.title,\n      scopeType: hook.hookName.includes(\"each\") ? \"each\" : \"all\",\n      position: hook.hookName.includes(\"before\") ? \"before\" : \"after\",\n      start: start ?? Date.now(),\n    },\n  });\n};\n\nexport const reportHookEnd = (hook: CypressHook) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_hook_end\",\n    data: {\n      duration: hook.duration ?? 0,\n    },\n  });\n};\n\nexport const reportTestStart = (test: CypressTest) => {\n  setCurrentTest(test);\n  enqueueRuntimeMessage({\n    type: \"cypress_test_start\",\n    data: getTestStartData(test),\n  });\n  markTestAsReported(test);\n};\n\nexport const reportUnfinishedSteps = (status: Status, statusDetails?: StatusDetails) => {\n  const runtimeMessages = getRuntimeMessages() as RuntimeMessage[];\n  const unfinishedStepsMessages = getUnfinishedStepsMessages(runtimeMessages);\n  unfinishedStepsMessages.forEach(() => {\n    enqueueRuntimeMessage({\n      type: \"step_stop\",\n      data: {\n        stop: Date.now(),\n        status,\n        statusDetails,\n      },\n    });\n  });\n};\n\nexport const reportTestPass = () => {\n  reportUnfinishedSteps(Status.PASSED);\n  enqueueRuntimeMessage({\n    type: \"cypress_test_pass\",\n    data: {},\n  });\n};\n\nexport const reportTestSkip = (test: CypressTest) => {\n  if (isTestReported(test)) {\n    reportUnfinishedCommand(Status.SKIPPED, {\n      message: \"The test was skipped before the command was completed\",\n    });\n  } else {\n    reportTestStart(test);\n  }\n\n  enqueueRuntimeMessage({\n    type: \"cypress_test_skip\",\n    data: getTestSkipData(),\n  });\n};\n\nexport const reportCommandStart = (command: CypressCommand) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_command_start\",\n    data: {\n      name: `Command \"${command.attributes.name}\"`,\n      args: command.attributes.args.map((arg) => (typeof arg === \"string\" ? arg : JSON.stringify(arg, null, 2))),\n      start: Date.now(),\n    },\n  });\n};\n\nexport const reportCommandEnd = () => {\n  enqueueRuntimeMessage({\n    type: \"cypress_command_end\",\n    data: {\n      status: Status.PASSED,\n      stop: Date.now(),\n    },\n  });\n};\n\nexport const reportScreenshot = (path: string, name: string) => {\n  enqueueRuntimeMessage({\n    type: \"attachment_path\",\n    data: {\n      path: path,\n      name: name || \"Screenshot\",\n      contentType: ContentType.PNG,\n    },\n  });\n};\n\nexport const reportUnfinishedCommand = (status: Status, statusDetails?: StatusDetails) => {\n  const runtimeMessages = getRuntimeMessages();\n  const startCommandMessageIdx = runtimeMessages.toReversed().findIndex(({ type }) => type === \"cypress_command_start\");\n  const stopCommandMessageIdx = runtimeMessages.toReversed().findIndex(({ type }) => type === \"cypress_command_end\");\n  const hasUnfinishedCommand = startCommandMessageIdx > stopCommandMessageIdx;\n\n  const data: CypressCommandEndMessage[\"data\"] = { status, stop: Date.now() };\n  if (statusDetails) {\n    data.statusDetails = statusDetails;\n  }\n\n  if (hasUnfinishedCommand) {\n    enqueueRuntimeMessage({ type: \"cypress_command_end\", data });\n  }\n};\n\nexport const reportTestOrHookFail = (err: Error) => {\n  const status = getStatusFromError(err);\n  const statusDetails = getMessageAndTraceFromError(err);\n\n  reportUnfinishedCommand(status, statusDetails);\n\n  enqueueRuntimeMessage({\n    type: \"cypress_fail\",\n    data: {\n      status,\n      statusDetails,\n    },\n  });\n};\n\nexport const reportTestEnd = (test: CypressTest) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_test_end\",\n    data: {\n      duration: test.duration ?? 0,\n      retries: (test as any)._retries ?? 0,\n    },\n  });\n  dropCurrentTest();\n};\n\nexport const completeHookErrorReporting = (hook: CypressHook, err: Error) => {\n  const isEachHook = hook.hookName.includes(\"each\");\n  const suite = hook.parent!;\n  const testFailData = getStatusDataOfTestSkippedByHookError(hook.title, isEachHook, err, suite);\n\n  // Cypress doens't emit 'hook end' if the hook has failed.\n  reportHookEnd(hook);\n\n  // Cypress doens't emit 'test end' if the hook has failed.\n  // We must report the test's end manualy in case of a 'before each' hook.\n  reportCurrentTestIfAny();\n\n  // Cypress skips the remaining tests in the suite of a failed hook.\n  // We should include them to the report manually.\n  reportRemainingTests(suite, testFailData);\n};\n\n/**\n * Patches the `after` function, to inject an extra `after` hook after each spec-level\n * `after` hook defined by the user.\n */\nexport const enableScopeLevelAfterHookReporting = () => {\n  const [getSuiteDepth, incSuiteDepth, decSuiteDepth] = createSuiteDepthCounterState();\n  patchDescribe(incSuiteDepth, decSuiteDepth);\n  patchAfter(getSuiteDepth);\n};\n\nexport const flushRuntimeMessages = () => getTestRuntime().flushAllureMessagesToTask(\"reportAllureCypressSpecMessages\");\n\nexport const completeSpec = () =>\n  getTestRuntime().flushAllureMessagesToTaskAsync(\"reportFinalAllureCypressSpecMessages\");\n\nexport const completeSpecIfNoAfterHookLeft = (context: Mocha.Context) => {\n  if (isLastRootAfterHook(context)) {\n    const hook = context.test as CypressHook;\n    if (!isAllureHook(hook)) {\n      reportHookEnd(hook);\n    }\n    return completeSpec();\n  }\n};\n\nconst completeSpecOnAfterHookFailure = (\n  context: Mocha.Context,\n  hookError: Error,\n): Cypress.Chainable<unknown> | undefined => {\n  try {\n    reportTestOrHookFail(hookError);\n    completeHookErrorReporting(context.test as CypressHook, hookError);\n\n    // cy.task's then doesn't have onrejected, that's why we don't log async Allure errors here.\n    return completeSpec();\n  } catch (allureError) {\n    logAllureRootAfterError(context, allureError);\n  }\n};\n\nconst reportCurrentTestIfAny = () => {\n  const currentTest = getCurrentTest();\n  if (currentTest) {\n    reportTestEnd(currentTest);\n  }\n};\n\nconst reportRemainingTests = (suite: CypressSuite, testFailData: CypressFailMessage[\"data\"]) => {\n  for (const test of iterateTests(suite)) {\n    // Some tests in the suite might've been already reported.\n    if (!isTestReported(test)) {\n      reportTestsSkippedByHookError(\n        test,\n        test.pending ? { ...getTestSkipData(), status: Status.SKIPPED } : testFailData,\n      );\n    }\n  }\n};\n\nconst reportTestsSkippedByHookError = (test: CypressTest, testFailData: CypressFailMessage[\"data\"]) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_skipped_test\",\n    data: {\n      ...getTestStartData(test),\n      ...testFailData,\n      ...getTestStopData(test),\n      suites: getSuites(test).map((s) => s.id),\n    },\n  });\n  markTestAsReported(test);\n};\n\nconst getStatusDataOfTestSkippedByHookError = (\n  hookTitle: string,\n  isEachHook: boolean,\n  err: Error,\n  suite: CypressSuite,\n) => {\n  const status = isEachHook ? Status.SKIPPED : getStatusFromError(err);\n  const { message, trace } = getMessageAndTraceFromError(err);\n  return {\n    status,\n    statusDetails: {\n      message: isEachHook ? getSkipReason(hookTitle, suite) : message,\n      trace,\n    },\n  };\n};\n\nconst getSkipReason = (hookTitle: string, suite: CypressSuite) => {\n  const suiteName = suite.title ? `'${suite.title}'` : \"root\";\n  return `'${hookTitle}' defined in the ${suiteName} suite has failed`;\n};\n\nconst forwardDescribeCall = (target: CypressSuiteFunction, ...args: Parameters<CypressSuiteFunction>) => {\n  const [title, configOrFn, fn] = args;\n  if (typeof fn === \"undefined\" && typeof configOrFn === \"undefined\") {\n    return target(title);\n  } else if (typeof configOrFn === \"function\") {\n    return target(title, configOrFn);\n  } else {\n    return target(title, configOrFn, fn);\n  }\n};\n\nconst patchDescribe = (incSuiteDepth: () => void, decSuiteDepth: () => void) => {\n  const patchDescribeFn =\n    (target: CypressSuiteFunction): CypressSuiteFunction =>\n    (title, configOrFn, fn) => {\n      incSuiteDepth();\n      try {\n        return forwardDescribeCall(target, title, configOrFn, fn);\n      } finally {\n        decSuiteDepth();\n      }\n    };\n  const originalDescribeFn: Mocha.SuiteFunction = globalThis.describe;\n  const patchedDescribe = patchDescribeFn(originalDescribeFn) as Mocha.SuiteFunction;\n  patchedDescribe.only = patchDescribeFn(\n    originalDescribeFn.only as CypressSuiteFunction,\n  ) as Mocha.ExclusiveSuiteFunction;\n  patchedDescribe.skip = patchDescribeFn(originalDescribeFn.skip as CypressSuiteFunction) as Mocha.PendingSuiteFunction;\n  globalThis.describe = patchedDescribe;\n};\n\nconst createSuiteDepthCounterState = (): [get: () => number, inc: () => void, dec: () => void] => {\n  let suiteDepth = 0;\n  return [\n    () => suiteDepth,\n    () => {\n      suiteDepth++;\n    },\n    () => {\n      suiteDepth--;\n    },\n  ];\n};\n\nconst patchAfter = (getSuiteDepth: () => number) => {\n  const originalAfter = globalThis.after;\n  const patchedAfter = (nameOrFn: string | HookImplementation, fn?: HookImplementation): void => {\n    return typeof nameOrFn === \"string\"\n      ? originalAfter(nameOrFn, wrapRootAfterFn(getSuiteDepth, fn))\n      : originalAfter(wrapRootAfterFn(getSuiteDepth, nameOrFn)!);\n  };\n  globalThis.after = patchedAfter;\n};\n\nconst wrapRootAfterFn = (getSuiteDepth: () => number, fn?: HookImplementation): HookImplementation | undefined => {\n  if (getSuiteDepth() === 0 && fn) {\n    const wrappedFn = fn.length ? wrapAfterFnWithCallback(fn) : wrapAfterFnWithoutArgs(fn as DirectHookImplementation);\n    Object.defineProperty(wrappedFn, \"name\", { value: fn.name });\n    return wrappedFn;\n  }\n  return fn;\n};\n\nconst wrapAfterFnWithCallback = (fn: Mocha.Func): Mocha.Func => {\n  return function (this: Mocha.Context, done: Mocha.Done) {\n    const wrappedDone = (hookError?: Error) => {\n      if (hookError) {\n        if (!completeSpecOnAfterHookFailure(this, hookError)?.then(() => done(hookError))) {\n          done(hookError);\n        }\n        return;\n      }\n\n      try {\n        if (completeSpecIfNoAfterHookLeft(this)?.then(() => done())) {\n          return;\n        }\n      } catch (allureError) {\n        done(allureError);\n        return;\n      }\n\n      done();\n    };\n    return fn.bind(this)(wrappedDone);\n  };\n};\n\nconst wrapAfterFnWithoutArgs = (fn: DirectHookImplementation) => {\n  return function (this: Mocha.Context) {\n    let result;\n    let syncError: any;\n\n    try {\n      result = fn.bind(this)();\n    } catch (e) {\n      syncError = e;\n    }\n\n    if (syncError) {\n      throwAfterSpecCompletion(this, syncError);\n    } else if (isPromise(result)) {\n      return result.then(\n        () => completeSpecIfNoAfterHookLeft(this),\n        (asyncError) => throwAfterSpecCompletion(this, asyncError),\n      );\n    } else {\n      completeSpecIfNoAfterHookLeft(this);\n      return result;\n    }\n  };\n};\n\nconst throwAfterSpecCompletion = (context: Mocha.Context, err: any) => {\n  const chain = completeSpecOnAfterHookFailure(context, err as Error)?.then(() => {\n    throw err;\n  });\n  if (!chain) {\n    throw err;\n  }\n};\n\nconst logAllureRootAfterError = (context: Mocha.Context, err: unknown) => {\n  // We play safe and swallow errors here to keep the original 'after all' error.\n  try {\n    // eslint-disable-next-line no-console\n    console.error(`Unexpected error when reporting the failure of ${context.test?.title ?? \"'after all'\"}`);\n    // eslint-disable-next-line no-console\n    console.error(err);\n  } catch {}\n};\n\nconst isLastRootAfterHook = (context: Mocha.Context) => {\n  const currentAfterAll = context.test as CypressHook;\n  const rootSuite = (context.test as CypressHook).parent!;\n  const hooks = (rootSuite as any).hooks as CypressHook[];\n  const lastAfterAll = hooks.findLast((h) => h.hookName === \"after all\");\n  return lastAfterAll?.hookId === currentAfterAll.hookId;\n};\n", "import { getMessageAndTraceFromError, getStatusFromError } from \"allure-js-commons/sdk\";\nimport { ALLURE_REPORT_SYSTEM_HOOK } from \"./model.js\";\nimport type { CypressCommand, CypressHook, CypressSuite, CypressTest } from \"./model.js\";\nimport {\n  completeHookErrorReporting,\n  completeSpecIfNoAfterHookLeft,\n  enableScopeLevelAfterHookReporting,\n  flushRuntimeMessages,\n  initTestRuntime,\n  reportCommandEnd,\n  reportCommandStart,\n  reportHookEnd,\n  reportHookStart,\n  reportRunStart,\n  reportScreenshot,\n  reportSuiteEnd,\n  reportSuiteStart,\n  reportTestEnd,\n  reportTestOrHookFail,\n  reportTestPass,\n  reportTestSkip,\n  reportTestStart,\n  reportUnfinishedSteps,\n} from \"./runtime.js\";\nimport { isAllureInitialized, setAllureInitialized } from \"./state.js\";\nimport { applyTestPlan, isAllureHook, isRootAfterAllHook, isTestReported, shouldCommandBeSkipped } from \"./utils.js\";\n\nconst {\n  EVENT_RUN_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_BEGIN,\n  EVENT_TEST_PASS,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_PENDING,\n  EVENT_TEST_END,\n} = Mocha.Runner.constants;\n\nconst initializeAllure = () => {\n  if (isAllureInitialized()) {\n    return;\n  }\n\n  setAllureInitialized();\n\n  // @ts-ignore\n  Cypress.mocha\n    .getRunner()\n    .on(EVENT_RUN_BEGIN, () => {\n      initTestRuntime();\n      reportRunStart();\n    })\n    .on(EVENT_SUITE_BEGIN, (suite: CypressSuite) => {\n      if (suite.root) {\n        applyTestPlan(Cypress.spec, suite);\n      }\n      reportSuiteStart(suite);\n    })\n    .on(EVENT_SUITE_END, (suite: CypressSuite) => {\n      reportSuiteEnd(suite);\n    })\n    .on(EVENT_HOOK_BEGIN, (hook: CypressHook) => {\n      if (isAllureHook(hook)) {\n        return;\n      }\n\n      reportHookStart(hook);\n    })\n    .on(EVENT_HOOK_END, (hook: CypressHook) => {\n      if (isAllureHook(hook)) {\n        return;\n      }\n\n      reportHookEnd(hook);\n    })\n    .on(EVENT_TEST_BEGIN, (test: CypressTest) => {\n      // Cypress emits an extra EVENT_TEST_BEGIN if the test is skipped.\n      // reportTestSkip does that already, so we need to filter the extra event out.\n      if (!isTestReported(test)) {\n        reportTestStart(test);\n      }\n    })\n    .on(EVENT_TEST_PASS, () => {\n      reportTestPass();\n    })\n    .on(EVENT_TEST_FAIL, (testOrHook: CypressTest | CypressHook, err: Error) => {\n      const isHook = \"hookName\" in testOrHook;\n      if (isHook && isRootAfterAllHook(testOrHook)) {\n        // Errors in spec-level 'after all' hooks are handled by Allure wrappers.\n        return;\n      }\n\n      const isAllureHookFailure = isHook && isAllureHook(testOrHook);\n\n      if (isAllureHookFailure) {\n        // Normally, Allure hooks are skipped from the report.\n        // In case of errors, it will be helpful to see them.\n        reportHookStart(testOrHook, Date.now() - (testOrHook.duration ?? 0));\n      }\n\n      // This will mark the fixture and the test (if any) as failed/broken.\n      reportTestOrHookFail(err);\n\n      if (isHook) {\n        // This will end the fixture and test (if any) and will report the remaining\n        // tests in the hook's suite (the ones that will be skipped by Cypress/Mocha).\n        completeHookErrorReporting(testOrHook, err);\n      }\n    })\n    .on(EVENT_TEST_PENDING, (test: CypressTest) => {\n      reportTestSkip(test);\n    })\n    .on(EVENT_TEST_END, (test: CypressTest) => {\n      reportTestEnd(test);\n    });\n\n  Cypress.Screenshot.defaults({\n    onAfterScreenshot: (_, { path, name }) => {\n      reportScreenshot(path, name);\n    },\n  });\n\n  Cypress.on(\"fail\", (err) => {\n    const status = getStatusFromError(err);\n    const statusDetails = getMessageAndTraceFromError(err);\n\n    reportUnfinishedSteps(status, statusDetails);\n\n    throw err;\n  });\n  Cypress.on(\"command:start\", (command: CypressCommand) => {\n    if (shouldCommandBeSkipped(command)) {\n      return;\n    }\n\n    reportCommandStart(command);\n  });\n  Cypress.on(\"command:end\", (command: CypressCommand) => {\n    if (shouldCommandBeSkipped(command)) {\n      return;\n    }\n\n    reportCommandEnd();\n  });\n\n  afterEach(ALLURE_REPORT_SYSTEM_HOOK, flushRuntimeMessages);\n\n  after(ALLURE_REPORT_SYSTEM_HOOK, function (this: Mocha.Context) {\n    flushRuntimeMessages();\n    completeSpecIfNoAfterHookLeft(this);\n  });\n\n  enableScopeLevelAfterHookReporting();\n};\n\ninitializeAllure();\n\nexport * from \"allure-js-commons\";\n"],
  "mappings": "AA8EA,IAAYA,EAAM,SAANA,EAAM,CAANA,OAAAA,EAAM,OAAA,SAANA,EAAM,OAAA,SAANA,EAAM,OAAA,SAANA,EAAM,QAAA,UAANA,CAAM,EAAA,CAAA,CAAA,EAOLC,GAAmB,CAACD,EAAOE,OAAQF,EAAOG,OAAQH,EAAOI,OAAQJ,EAAOK,OAAO,EAGhFC,GAAK,SAALA,EAAK,CAALA,OAAAA,EAAK,UAAA,YAALA,EAAK,QAAA,UAALA,EAAK,SAAA,WAALA,EAAK,QAAA,UAALA,EAAK,YAAA,cAALA,CAAK,EAAA,CAAA,CAAA,EASLC,EAAS,SAATA,EAAS,CAATA,OAAAA,EAAS,UAAA,YAATA,EAAS,MAAA,YAATA,EAAS,MAAA,QAATA,EAAS,aAAA,cAATA,EAAS,UAAA,WAATA,EAAS,KAAA,OAATA,EAAS,QAAA,UAATA,EAAS,MAAA,QAATA,EAAS,SAAA,WAATA,EAAS,IAAA,MAATA,EAAS,MAAA,QAATA,EAAS,KAAA,OAATA,EAAS,KAAA,OAATA,EAAS,OAAA,SAATA,EAAS,YAAA,aAATA,EAAS,WAAA,YAATA,EAAS,QAAA,UAATA,EAAS,UAAA,YAATA,EAAS,SAAA,WAATA,EAAS,MAAA,QAATA,CAAS,EAAA,CAAA,CAAA,EA2BTC,GAAQ,SAARA,EAAQ,CAARA,OAAAA,EAAQ,QAAA,UAARA,EAAQ,SAAA,WAARA,EAAQ,OAAA,SAARA,EAAQ,MAAA,QAARA,EAAQ,QAAA,UAARA,CAAQ,EAAA,CAAA,CAAA,EASRC,EAAW,SAAXA,EAAW,CAAXA,OAAAA,EAAW,KAAA,aAAXA,EAAW,IAAA,kBAAXA,EAAW,KAAA,YAAXA,EAAW,IAAA,WAAXA,EAAW,IAAA,4BAAXA,EAAW,IAAA,WAAXA,EAAW,IAAA,gBAAXA,EAAW,IAAA,gBAAXA,EAAW,IAAA,YAAXA,EAAW,KAAA,mBAAXA,EAAW,IAAA,kBAAXA,EAAW,KAAA,aAAXA,EAAW,KAAA,aAAXA,EAAW,IAAA,YAAXA,EAAW,UAAA,oCAAXA,CAAW,EAAA,CAAA,CAAA,EAmBXC,EAAQ,SAARA,EAAQ,CAARA,OAAAA,EAAQ,QAAA,OAARA,EAAQ,MAAA,QAARA,EAAQ,IAAA,MAARA,CAAQ,EAAA,CAAA,CAAA,o4CCpJb,IAAMC,EAAsBC,GAAyB,CAC1D,OAAQ,GAAI,CAOV,IAAK,WAAWC,KAAKD,EAAME,YAAYC,IAAI,EAC3C,IAAK,gBAAgBF,KAAKD,EAAME,YAAYC,IAAI,EAChD,IAAK,WAAWF,KAAKD,EAAMG,IAAI,EAC/B,IAAK,WAAWF,KAAKD,EAAMI,OAAO,EAClC,KAAKJ,EAAMK,OAAS,oBAAoBJ,KAAKD,EAAMK,KAAK,GACtD,OAAOC,EAAOC,OAChB,QACE,OAAOD,EAAOE,MAClB,CACF,EAKMC,GAAY,UAAgC,CAAA,GAA/B,CAAEC,UAAAA,EAAY,EAAM,EAACC,UAAAC,OAAA,GAAAD,UAAA,CAAA,IAAAE,OAAAF,UAAA,CAAA,EAAG,CAAC,EACpCG,EAAU,CACd,+HACA,0DAA0D,EAC1DC,KAAK,GAAG,EAEV,OAAO,IAAIC,OAAOF,EAASJ,EAAYG,OAAY,GAAG,CACxD,EAKaI,EAAaC,GAAwB,CAChD,IAAMC,EAAQV,GAAU,EACxB,OAAOS,EAAIE,QAAQD,EAAO,EAAE,CAC9B,EAEaE,EACXrB,GAC6C,CAC7C,GAAM,CAAEI,QAAAA,EAASC,MAAAA,CAAM,EAAIL,EAC3B,MAAO,CACLI,QAASA,EAAUa,EAAUb,CAAO,EAAIS,OACxCS,MAAOjB,EAAQY,EAAUZ,CAAK,EAAIQ,MACpC,CACF,EAEaU,GAAcC,EAAG,mCAAuC,CAAAC,GAAA,CAAA,CAAA,EACxDC,GAAuB,IAAIV,OAAOO,GAAgB,GAAG,EACrDI,GAAiBH,EAAG,kDAAgE,CAAArB,KAAA,EAAAyB,MAAA,CAAA,CAAA,EACpFC,GAA0B,IAAIb,OAAOW,GAAmB,GAAG,EAMjE,IAAMG,EACXC,GAIG,CACH,IAAMC,EAAS,CAAA,EAEfD,EAAME,MAAM,GAAG,EAAEC,QAASC,GAAQ,CAAA,IAAAC,EAC1BC,GAAOD,EAAGD,EAAIG,MAAMC,EAAc,KAAC,MAAAH,IAAA,SAAAA,EAAzBA,EAA2BI,UAAM,MAAAJ,IAAA,OAAA,OAAjCA,EAAmCK,GAE/CJ,GACFL,EAAOU,KAAK,CAAEC,KAAMC,EAAUC,UAAWC,MAAOT,CAAQ,CAAC,EAG3D,IAAMU,EAAaZ,EAAIG,MAAMU,EAAiB,EACxC,CAAEL,KAAAA,EAAMG,MAAAA,CAAM,EAAIC,GAAYP,QAAU,CAAC,EAE3CG,GAAQG,GACVd,GAAQU,KAAK,CAAEC,KAAAA,EAAMG,MAAAA,CAAM,CAAC,CAEhC,CAAC,EAED,IAAMG,EAAalB,EAAMmB,QAAQC,GAAyB,EAAE,EAAED,QAAQE,GAAsB,EAAE,EAAEC,KAAK,EAErG,MAAO,CAAErB,OAAAA,EAAQiB,WAAAA,CAAW,CAC9B,EAwBO,IAAMK,GAAwBC,GACnCA,EAASC,OAAO,CAACC,EAAKC,IAAY,CAChC,GAAIA,EAAQC,OAAS,cAAgBD,EAAQC,OAAS,YACpD,OAAOF,EAGT,GAAIC,EAAQC,OAAS,aACnBF,OAAAA,EAAIG,KAAK,CAACF,CAAO,CAAC,EAEXD,EAGT,IAAMI,EAAoBJ,EAAIK,cAAeC,GAASA,EAAKC,SAAW,CAAC,EAEvE,OAAIH,IAAsB,IAI1BJ,EAAII,CAAiB,EAAED,KAAKF,CAAO,EAE5BD,CACT,EAAG,CAAA,CAAwB,EAEhBQ,EAA8BV,GAA+B,CACxE,IAAMW,EAAuBZ,GAAqBC,CAAQ,EAE1D,OAAOW,EAAqBC,OAAQJ,GAASA,EAAKC,SAAW,CAAC,CAChE,EAEaI,EAAsBC,GACjC,CAAC,CAACA,IAAQ,OAAOA,GAAQ,UAAY,OAAOA,GAAQ,aAAe,OAAOA,EAAIC,MAAS,WC1IlF,IAAMC,EAA4B,gCAE5BC,EAA6B,8VCJnC,IAAMC,EAAN,KAA6C,CAC5CC,YAAa,CAAA,IAAAC,EAAA,KAAA,OAAAC,EAAA,WAAA,CACjB,MAAMD,EAAKE,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMC,oBAAqB,CAAA,IAAAC,EAAA,KAAA,OAAAH,EAAA,WAAA,CACzB,MAAMG,EAAKF,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMG,aAAc,CAAA,IAAAC,EAAA,KAAA,OAAAL,EAAA,WAAA,CAClB,MAAMK,EAAKJ,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMK,iBAAkB,CAAA,IAAAC,EAAA,KAAA,OAAAP,EAAA,WAAA,CACtB,MAAMO,EAAKN,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMO,aAAc,CAAA,IAAAC,EAAA,KAAA,OAAAT,EAAA,WAAA,CAClB,MAAMS,EAAKR,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMS,WAAY,CAAA,IAAAC,EAAA,KAAA,OAAAX,EAAA,WAAA,CAChB,MAAMW,EAAKV,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMW,QAAS,CAAA,IAAAC,EAAA,KAAA,OAAAb,EAAA,WAAA,CACb,MAAMa,EAAKZ,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMa,OAAQ,CAAA,IAAAC,EAAA,KAAA,OAAAf,EAAA,WAAA,CACZ,MAAMe,EAAKd,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMe,WAAY,CAAA,IAAAC,EAAA,KAAA,OAAAjB,EAAA,WAAA,CAChB,MAAMiB,EAAKhB,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMiB,SAAU,CAAA,IAAAC,EAAA,KAAA,OAAAnB,EAAA,WAAA,CACd,MAAMmB,EAAKlB,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMmB,KAAQC,EAAcC,EAA4C,CAAA,IAAAC,EAAA,KAAA,OAAAvB,EAAA,WAAA,CACtE,aAAMuB,EAAKtB,QAAQ,EACZqB,EAAK,CAAE,CAAA,EAAA,CAChB,CAEME,iBAAkB,CAAA,IAAAC,EAAA,KAAA,OAAAzB,EAAA,WAAA,CACtB,MAAMyB,EAAKxB,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEMyB,eAAgB,CAAA,IAAAC,EAAA,KAAA,OAAA3B,EAAA,WAAA,CACpB,MAAM2B,EAAK1B,QAAQ,CAAE,CAAA,EAAA,CACvB,CAEM2B,YAAa,CAAA,IAAAC,EAAA,KAAA,OAAA7B,EAAA,WAAA,CACjB,MAAM6B,EAAK5B,QAAQ,CAAE,CAAA,EAAA,CACvB,CAGMA,SAAU,CAAA,OAAAD,EAAA,WAAA,CAEd8B,QAAQC,IAAI,qEAAqE,CAAE,CAAA,EAAA,CACrF,CACF,EAEaC,EAA2B,IAAInC,EChE5C,IAAMoC,GAA0B,oBAEnBC,EAAwBC,GAAyB,CAC3DC,WAAmBH,EAAuB,EAAI,IAAME,CACvD,EAEME,EAA+BA,IAC3BD,aAAqBH,EAAuB,EAGzCK,EAAuBA,IAAmB,CACrD,IAAMC,EAAcF,EAA6B,EAEjD,GAAIE,EAAa,CAAA,IAAAC,EACf,OAAAA,EAAOD,EAAY,KAAC,MAAAC,IAAA,OAAAA,EAAIC,CAC1B,CAEA,OAAOA,CACT,EAEaC,EAAqCA,IAA0C,CAC1F,IAAMH,EAAcF,EAA6B,EAEjD,GAAIE,EAAa,CAAA,IAAAI,EACf,OAAAA,EAAOJ,EAAY,KAAC,MAAAI,IAAA,OAAAA,EAAIF,CAC1B,CAEA,GAAI,wBAAyBL,WAC3B,GAAI,CAIF,SAAWQ,MAAM,kDAAkD,EAAEC,KAAK,IAAM,CAAA,IAAAC,EAAAC,EAC9E,OAAAD,GAAAC,EAAOV,EAA6B,KAAC,MAAAU,IAAA,OAAA,OAA9BA,EAAiC,KAAC,MAAAD,IAAA,OAAAA,EAAIL,CAC/C,CAAC,CACH,OAASO,EAAK,CAEZC,eAAQC,IAAI,6CAA8CF,CAAG,EACtDP,CACT,CAGF,OAAOA,CACT,ECtCA,IAAMU,EAAoB,SAKxBC,EAEM,CAAA,QAAAC,EAAAC,UAAAC,OADHC,EAAI,IAAAC,MAAAJ,EAAA,EAAAA,EAAA,EAAA,CAAA,EAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,EAAA,CAAA,EAAAJ,UAAAI,CAAA,EAEP,IAAMC,EAAUC,EAAmC,EAEnD,OAAKC,EAAUF,CAAO,EAKfA,EAAQG,KAAMC,GAEZA,EAAYX,CAAM,EAAE,GAAGI,CAAI,CACnC,EANQG,EAAQP,CAAM,EAAE,GAAGI,CAAI,CAOlC,EAEaQ,EAAQA,CAACC,EAA0BC,IACvCf,EAAkB,SAAU,CAAEc,KAAAA,EAAMC,MAAAA,CAAM,CAAC,EAGvCC,GAAS,UAA4B,CAAA,QAAAC,EAAAd,UAAAC,OAAxBc,EAAU,IAAAZ,MAAAW,CAAA,EAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAVD,EAAUC,CAAA,EAAAhB,UAAAgB,CAAA,EAClC,OAAOnB,EAAkB,SAAU,GAAGkB,CAAU,CAClD,EAEaE,EAAOA,CAACC,EAAaP,EAAeQ,IACxCtB,EAAkB,QAAS,CAAEqB,IAAAA,EAAKC,KAAAA,EAAMR,KAAAA,CAAK,CAAC,EAG1CS,GAAQ,UAA0B,CAAA,QAAAC,EAAArB,UAAAC,OAAtBqB,EAAS,IAAAnB,MAAAkB,CAAA,EAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAATD,EAASC,CAAA,EAAAvB,UAAAuB,CAAA,EAChC,OAAO1B,EAAkB,QAAS,GAAGyB,CAAS,CAChD,EAEaE,GAAYA,CAACb,EAAcC,EAAea,IAC9C5B,EAAkB,YAAac,EAAMC,EAAOa,CAAO,EAG/CC,GAAeC,GACnB9B,EAAkB,cAAe8B,CAAQ,EAGrCC,GAAmBC,GACvBhC,EAAkB,kBAAmBgC,CAAI,EAGrCC,GAAenB,GACnBd,EAAkB,cAAec,CAAI,EAGjCoB,GAAanB,GACjBf,EAAkB,YAAae,CAAK,EAGhCoB,GAAcpB,GAClBf,EAAkB,aAAce,CAAK,EAGjCqB,GAAaA,CACxBtB,EACAuB,EACAT,IACG,CACH,IAAMU,EAAO,OAAOV,GAAY,SAAW,CAAEW,YAAaX,CAAQ,EAAIA,EACtE,OAAO5B,EAAkB,aAAcc,EAAMuB,EAASC,CAAI,CAC5D,EAEaE,GAAiBA,CAC5B1B,EACA2B,EACAb,IACG,CACH,IAAMU,EAAO,OAAOV,GAAY,SAAW,CAAEW,YAAaX,CAAQ,EAAIA,EACtE,OAAO5B,EAAkB,qBAAsBc,EAAM2B,EAAMH,CAAI,CACjE,EAOMI,GAAiCA,KAAO,CAC5CT,YAAcnB,GACLd,EAAkB,kBAAmBc,CAAI,EAElDa,UAAWA,CAACb,EAAMC,EAAO4B,IAChB3C,EAAkB,gBAAiBc,EAAMC,EAAO4B,CAAI,CAE/D,GAEaC,GAAUA,CAAC9B,EAAc+B,EAAiBC,IAC9C9C,EAAkB,UAAWc,EAAM+B,EAAQC,CAAK,EAG5CC,GAAOA,CAAWjC,EAAckC,IACpChD,EAAkB,OAAQc,EAAM,IAAMkC,EAAKN,GAAY,CAAC,CAAC,EAGrDO,GAAQA,CAAC5B,EAAaP,IAAkBM,EAAKC,EAAKP,EAAMoC,EAASC,KAAK,EAEtEC,GAAMA,CAAC/B,EAAaP,IAAkBM,EAAKC,EAAKP,EAAMoC,EAASG,GAAG,EAElEC,GAAYvC,GAAkBF,EAAM0C,EAAUC,UAAWzC,CAAK,EAE9D0C,GAAQ3C,GAAiBD,EAAM0C,EAAUG,KAAM5C,CAAI,EAEnD6C,GAAW7C,GAAiBD,EAAM0C,EAAUK,QAAS9C,CAAI,EAEzD+C,GAAS/C,GAAiBD,EAAM0C,EAAUO,MAAOhD,CAAI,EAErDiD,GAASjD,GAAiBD,EAAM0C,EAAUS,MAAOlD,CAAI,EAErDmD,GAAenD,GAAiBD,EAAM0C,EAAUW,aAAcpD,CAAI,EAElEqD,GAAYrD,GAAiBD,EAAM0C,EAAUa,UAAWtD,CAAI,EAE5DuD,GAASvD,GAAiBD,EAAM0C,EAAUe,MAAOxD,CAAI,EAErDyD,GAAYzD,GAAiBD,EAAM0C,EAAUiB,SAAU1D,CAAI,EAE3D2D,GAAS3D,GAAiBD,EAAM0C,EAAUmB,MAAO5D,CAAI,EAErD6D,GAAO7D,GAAiBD,EAAM0C,EAAUqB,IAAK9D,CAAI,EAEjD+D,GAAO,UAA2B,CAAA,QAAAC,EAAA3E,UAAAC,OAAvB2E,EAAQ,IAAAzE,MAAAwE,CAAA,EAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAARD,EAAQC,CAAA,EAAA7E,UAAA6E,CAAA,EAC9B,OAAOhF,EAAkB,SAAU,GAAG+E,EAASE,IAAKlE,IAAW,CAAED,KAAMyC,EAAUqB,IAAK7D,MAAAA,CAAM,EAAE,CAAC,CACjG,ECvIO,IAAMmE,EAAiB,IAAM,CAClC,IAAIC,EAAQ,QAAQ,IAAI,QAAQ,EAChC,OAAKA,IACHA,EAAQ,CACN,YAAa,GACb,SAAU,CAAC,EACX,SAAU,OACV,YAAa,MACf,EACA,QAAQ,IAAI,SAAUA,CAAK,GAEtBA,CACT,EAEaC,GAAsB,IAAMF,EAAe,EAAE,YAE7CG,GAAuB,IAAM,CACxCH,EAAe,EAAE,YAAc,EACjC,EAEaI,EAAqB,IAAMJ,EAAe,EAAE,SAE5CK,GAAsBC,GAA4B,CAC7DN,EAAe,EAAE,SAAWM,CAC9B,EAEaC,EAAyBC,GAA4B,CAChEJ,EAAmB,EAAE,KAAKI,CAAO,CACnC,EAEaC,GAAoB,IAAMT,EAAe,EAAE,SAE3CU,GAAiB,IAAMV,EAAe,EAAE,YAExCW,GAAkBC,GAAsB,CACnDZ,EAAe,EAAE,YAAcY,CACjC,EAEaC,GAAkB,IAAM,CACnCb,EAAe,EAAE,YAAc,MACjC,ECnCO,IAAMc,GAAsBC,GAEb,MAAM,QAAQA,CAAI,GAAKA,EAAK,OAOzC,KAAK,OAAO,aAAa,MAAM,KAAMA,CAAgB,CAAC,EAJpDA,EAOEC,GAAaC,GAAsB,CAC9C,IAAMC,EAAyB,CAAC,EAChC,QAAS,EAA8BD,EAAK,OAAQ,EAAG,EAAI,EAAE,OAC3DC,EAAO,KAAK,CAAC,EAEf,OAAAA,EAAO,QAAQ,EACRA,CACT,EAOO,IAAMC,EAA0BC,GACjCC,GAAKD,EAAQ,WAAW,IAAI,GAAG,MAAQ,IAIvCA,EAAQ,WAAW,OAAS,QAAUA,EAAQ,WAAW,KAAK,CAAC,IAAM,+BAKrEA,EAAQ,WAAW,OAAS,QAK5BA,EAAQ,WAAW,OAAS,QAAUA,EAAQ,WAAW,KAAK,CAAC,IAAME,EAiBpE,IAAMC,GAAqBC,GACzBA,EAAIA,EAAI,OAAS,CAAC,EAGdC,GAAoB,CAACC,EAAoBC,IAAsB,CAC1E,IAAMC,EAAUD,EAAK,MACf,CAAE,WAAYE,EAAM,OAAAC,CAAO,EAAIC,EAA0BH,CAAO,EAChEI,EAASL,EAAK,UAAU,EAAE,MAAM,EAAG,EAAE,EACrCM,EAAW,GAAGP,EAAK,QAAQ,IAAI,CAAC,GAAGM,EAAQH,CAAI,EAAE,KAAK,GAAG,CAAC,GAChE,MAAO,CAAE,KAAAA,EAAM,OAAAC,EAAQ,SAAAG,CAAS,CAClC,EAEaC,EAAoBP,IAAuB,CACtD,GAAGF,GAAkB,QAAQ,KAAME,CAAI,EACvC,MAAOA,EAAK,oBAAoB,QAAQ,GAAK,KAAK,IAAI,CACxD,GAEaQ,GAAmBR,IAAuB,CACrD,SAAUA,EAAK,UAAY,EAC3B,QAAUA,EAAa,UAAY,CACrC,GAEaS,EAAkB,KAAO,CACpC,cAAe,CAAE,QAAS,wBAAyB,CACrD,GAEaC,GAAgB,CAACX,EAAoBY,IAAuB,CACvE,IAAMC,EAAWC,GAAkB,EACnC,GAAID,EACF,QAAWE,KAASC,GAAcJ,CAAI,EAAG,CACvC,IAAMK,EAAkBC,GAA4BL,EAAUb,EAAMe,EAAM,KAAK,EAC/EI,GAAoBJ,EAAM,MAAOE,CAAe,CAClD,CAEJ,EAUA,IAAMG,GAAkB,OAAO,iCAAiC,EAEnDC,EAAsBC,GAAsB,CACtDA,EAAaF,EAAe,EAAI,EACnC,EAEaG,EAAkBD,GAAuBA,EAAaF,EAAe,IAAM,GAE3EI,GAAgB,UAAWC,EAAsB,CAC5D,IAAMC,EAA6B,CAAC,EACpC,QAAS,EAA8BD,EAAQ,EAAG,EAAIC,EAAW,IAAI,EAAG,CACtE,MAAM,EAIN,QAASC,EAAI,EAAE,OAAO,OAAS,EAAGA,GAAK,EAAGA,IACxCD,EAAW,KAAK,EAAE,OAAOC,CAAC,CAAC,CAE/B,CACF,EAEaC,GAAe,UAAWH,EAAsB,CAC3D,QAAWI,KAASL,GAAcC,CAAM,EACtC,MAAOI,EAAM,KAEjB,EAEaC,EAAgBC,GAAsBA,EAAK,MAAM,SAASC,CAAyB,EAEnFC,GAAsBF,GAAsBA,EAAK,OAAQ,MAAQA,EAAK,WAAa,YAE1FG,GAAqB,CAACC,EAAsBC,EAAkBC,IAClEF,EAAS,MAAM,KAAMb,GAAUe,GAAYf,EAAK,IAAI,SAAS,IAAMe,GAAaf,EAAK,WAAac,CAAQ,EAEtGE,GAA8B,CAACH,EAAsBI,EAAoBC,IAAkC,CAC/G,IAAMC,EAA4B,CAAC,EACnC,OAAAD,EAAM,QAAQ,CAAClB,EAAMoB,IAAU,CAC7B,GAAM,CAAE,SAAAN,EAAU,OAAAO,CAAO,EAAIC,GAAkBL,EAAMjB,CAAI,EACnDe,EAAWM,EAAO,KAAK,CAAC,CAAE,KAAAE,CAAK,IAAMA,IAASC,EAAU,SAAS,GAAG,MAErEZ,GAAmBC,EAAUC,EAAUC,CAAQ,GAClDI,EAAgB,KAAKC,CAAK,CAE9B,CAAC,EACMD,CACT,EAEMM,GAAsB,CAAIC,EAAUC,IAA+B,CACvE,QAAStB,EAAIsB,EAAQ,OAAS,EAAGtB,GAAK,EAAGA,IACvCqB,EAAI,OAAOC,EAAQtB,CAAC,EAAG,CAAC,CAE5B,ECnHO,IAAMuB,EAAN,KAAsD,CAC3D,aAAc,CACZ,KAAKC,GAAe,CACtB,CAEA,UAAUC,EAAiB,CACzB,OAAO,KAAKC,GAAqB,CAC/B,KAAM,WACN,KAAM,CACJ,OAAAD,CACF,CACF,CAAC,CACH,CAEA,SAASE,EAAe,CACtB,OAAO,KAAKD,GAAqB,CAC/B,KAAM,WACN,KAAM,CACJ,MAAAC,CACF,CACF,CAAC,CACH,CAEA,UAAUC,EAAcC,EAAeC,EAA4B,CACjE,OAAO,KAAKJ,GAAqB,CAC/B,KAAM,WACN,KAAM,CACJ,WAAY,CACV,CACE,KAAAE,EACA,MAAAC,EACA,GAAGC,CACL,CACF,CACF,CACF,CAAC,CACH,CAEA,YAAYC,EAAkB,CAC5B,OAAO,KAAKL,GAAqB,CAC/B,KAAM,WACN,KAAM,CACJ,YAAaK,CACf,CACF,CAAC,CACH,CAEA,gBAAgBC,EAAc,CAC5B,OAAO,KAAKN,GAAqB,CAC/B,KAAM,WACN,KAAM,CACJ,gBAAiBM,CACnB,CACF,CAAC,CACH,CAEA,YAAYJ,EAAc,CACxB,OAAO,KAAKF,GAAqB,CAC/B,KAAM,WACN,KAAM,CACJ,YAAaE,CACf,CACF,CAAC,CACH,CAEA,UAAUC,EAAe,CACvB,OAAO,KAAKH,GAAqB,CAC/B,KAAM,WACN,KAAM,CACJ,UAAWG,CACb,CACF,CAAC,CACH,CAEA,WAAWA,EAAe,CACxB,OAAO,KAAKH,GAAqB,CAC/B,KAAM,WACN,KAAM,CACJ,WAAYG,CACd,CACF,CAAC,CACH,CAGA,WAAWD,EAAcK,EAAiBH,EAA4B,CAEpE,IAAMI,EAA4CD,GAAS,OAAS,SAAWA,EAAQ,KAAOA,EACxFE,EAAiB,OAAOD,GAAyB,SAAW,OAAS,SACrEE,EAAoBC,GAAmBH,CAAoB,EAEjE,OAAO,KAAKR,GAAqB,CAC/B,KAAM,qBACN,KAAM,CACJ,KAAAE,EACA,QAASQ,EACT,SAAUD,EACV,YAAaL,EAAQ,YACrB,cAAeA,EAAQ,aACzB,CACF,CAAC,CACH,CAEA,mBAAmBF,EAAcU,EAAcR,EAA8C,CAC3F,OAAO,KAAKJ,GAAqB,CAC/B,KAAM,kBACN,KAAM,CACJ,KAAAE,EACA,KAAAU,EACA,YAAaR,EAAQ,YACrB,cAAeA,EAAQ,aACzB,CACF,CAAC,CACH,CAEA,QAAQF,EAAcW,EAAiBC,EAAO,OAAQC,EAAe,CACnE,OAAO,GACJ,KAAKC,EAA4B,CAAE,IAAK,EAAM,CAAC,EAC/C,KAAK,KACJ,KAAKhB,GAAqB,CACxB,KAAM,aACN,KAAM,CACJ,KAAAE,EACA,MAAO,KAAK,IAAI,CAClB,CACF,CAAC,EAEM,QAAQ,QAAQ,QAAQ,EAChC,EACA,KAAK,IACG,KAAKF,GAAqB,CAC/B,KAAM,YACN,KAAM,CACJ,OAAQa,EACR,KAAM,KAAK,IAAI,EACf,cAAeE,EAAQ,CAAE,GAAGE,EAA4BF,CAAK,CAAE,EAAI,MACrE,CACF,CAAC,CACF,CACL,CAEA,KAAeb,EAAcgB,EAAgC,CAC3D,OAAO,GACJ,KAAKF,EAA4B,CAAE,IAAK,EAAM,CAAC,EAC/C,KAAK,KACJ,KAAKhB,GAAqB,CACxB,KAAM,aACN,KAAM,CACJ,KAAAE,EACA,MAAO,KAAK,IAAI,CAClB,CACF,CAAC,EAEM,QAAQ,QAAQ,QAAQgB,EAAK,CAAC,EACtC,EACA,KAAMC,GACE,KAAKnB,GAAqB,CAC/B,KAAM,YACN,KAAM,CACJ,OAAQc,EAAO,OACf,KAAM,KAAK,IAAI,CACjB,CACF,CAAC,EAAE,KAAK,IAAMK,CAAM,CACrB,CACL,CAEA,gBAAgBjB,EAAc,CAC5B,OAAO,KAAKF,GAAqB,CAC/B,KAAM,gBACN,KAAM,CACJ,KAAAE,CACF,CACF,CAAC,CACH,CAEA,cAAcA,EAAcC,EAAeiB,EAAsB,CAC/D,OAAO,KAAKpB,GAAqB,CAC/B,KAAM,gBACN,KAAM,CACJ,WAAY,CAAC,CAAE,KAAAE,EAAM,MAAAC,EAAO,KAAAiB,CAAK,CAAC,CACpC,CACF,CAAC,CACH,CAEA,0BAA6BC,GAAqB,CAChD,IAAMC,EAAW,KAAKC,GAAoB,EACtCD,EAAS,QACX,GAAG,KAAKD,EAAU,CAAE,aAAc,QAAQ,KAAK,SAAU,SAAAC,CAAS,EAAG,CAAE,IAAK,EAAM,CAAC,CAEvF,EAEA,+BAAkCD,GAA6D,CAC7F,IAAMC,EAAW,KAAKC,GAAoB,EAC1C,GAAID,EAAS,OAAQ,CACnB,IAAME,EAA8B,CAClC,aAAc,QAAQ,KAAK,SAC3B,SAAAF,EACA,cAAe,QAAQ,OAAO,eAAe,CAC/C,EACA,OAAO,GAAG,KAAKD,EAAUG,EAAM,CAAE,IAAK,EAAM,CAAC,CAC/C,CACF,EAEA1B,GAAiB,IAAM2B,GAAmB,CAAC,CAAC,EAE5CzB,GAAwB0B,IACtBC,EAAsBD,CAAO,EACtB,QAAQ,QAAQ,QAAQ,GAGjCH,GAAsB,IAAM,CAC1B,IAAMD,EAAWM,EAAmB,EACpC,YAAK9B,GAAe,EACbwB,CACT,CACF,EAEaO,GAAkB,IAAMC,EAAqB,IAAIjC,CAAyC,EAE1FkC,GAAiB,IAAMC,EAAqB,EAE5CC,GAAiB,IAAM,CAClCN,EAAsB,CACpB,KAAM,oBACN,KAAM,CAAC,CACT,CAAC,CACH,EAEaO,GAAoBC,GAAwB,CACvDR,EAAsB,CACpB,KAAM,sBACN,KAAM,CACJ,GAAIQ,EAAM,GACV,KAAMA,EAAM,MACZ,KAAMA,EAAM,KACZ,MAAO,KAAK,IAAI,CAClB,CACF,CAAC,CACH,EAEaC,GAAkBD,GAAwB,CACrDR,EAAsB,CACpB,KAAM,oBACN,KAAM,CACJ,KAAMQ,EAAM,KACZ,KAAM,KAAK,IAAI,CACjB,CACF,CAAC,CACH,EAEaE,EAAkB,CAACC,EAAmBC,IAAmB,CACpEZ,EAAsB,CACpB,KAAM,qBACN,KAAM,CACJ,KAAMW,EAAK,MACX,UAAWA,EAAK,SAAS,SAAS,MAAM,EAAI,OAAS,MACrD,SAAUA,EAAK,SAAS,SAAS,QAAQ,EAAI,SAAW,QACxD,MAAOC,GAAS,KAAK,IAAI,CAC3B,CACF,CAAC,CACH,EAEaC,EAAiBF,GAAsB,CAClDX,EAAsB,CACpB,KAAM,mBACN,KAAM,CACJ,SAAUW,EAAK,UAAY,CAC7B,CACF,CAAC,CACH,EAEaG,EAAmBC,GAAsB,CACpDC,GAAeD,CAAI,EACnBf,EAAsB,CACpB,KAAM,qBACN,KAAMiB,EAAiBF,CAAI,CAC7B,CAAC,EACDG,EAAmBH,CAAI,CACzB,EAEaI,EAAwB,CAACjC,EAAgBkC,IAAkC,CACtF,IAAMC,EAAkBpB,EAAmB,EACXqB,EAA2BD,CAAe,EAClD,QAAQ,IAAM,CACpCrB,EAAsB,CACpB,KAAM,YACN,KAAM,CACJ,KAAM,KAAK,IAAI,EACf,OAAAd,EACA,cAAAkC,CACF,CACF,CAAC,CACH,CAAC,CACH,EAEaG,GAAiB,IAAM,CAClCJ,EAAsBhC,EAAO,MAAM,EACnCa,EAAsB,CACpB,KAAM,oBACN,KAAM,CAAC,CACT,CAAC,CACH,EAEawB,GAAkBT,GAAsB,CAC/CU,EAAeV,CAAI,EACrBW,GAAwBvC,EAAO,QAAS,CACtC,QAAS,uDACX,CAAC,EAED2B,EAAgBC,CAAI,EAGtBf,EAAsB,CACpB,KAAM,oBACN,KAAM2B,EAAgB,CACxB,CAAC,CACH,EAEaC,GAAsBC,GAA4B,CAC7D7B,EAAsB,CACpB,KAAM,wBACN,KAAM,CACJ,KAAM,YAAY6B,EAAQ,WAAW,IAAI,IACzC,KAAMA,EAAQ,WAAW,KAAK,IAAKC,GAAS,OAAOA,GAAQ,SAAWA,EAAM,KAAK,UAAUA,EAAK,KAAM,CAAC,CAAE,EACzG,MAAO,KAAK,IAAI,CAClB,CACF,CAAC,CACH,EAEaC,GAAmB,IAAM,CACpC/B,EAAsB,CACpB,KAAM,sBACN,KAAM,CACJ,OAAQb,EAAO,OACf,KAAM,KAAK,IAAI,CACjB,CACF,CAAC,CACH,EAEa6C,GAAmB,CAAC/C,EAAcV,IAAiB,CAC9DyB,EAAsB,CACpB,KAAM,kBACN,KAAM,CACJ,KAAMf,EACN,KAAMV,GAAQ,aACd,YAAa0D,EAAY,GAC3B,CACF,CAAC,CACH,EAEaP,GAA0B,CAACxC,EAAgBkC,IAAkC,CACxF,IAAMC,EAAkBpB,EAAmB,EACrCiC,EAAyBb,EAAgB,WAAW,EAAE,UAAU,CAAC,CAAE,KAAAc,CAAK,IAAMA,IAAS,uBAAuB,EAC9GC,EAAwBf,EAAgB,WAAW,EAAE,UAAU,CAAC,CAAE,KAAAc,CAAK,IAAMA,IAAS,qBAAqB,EAC3GE,EAAuBH,EAAyBE,EAEhDE,EAAyC,CAAE,OAAApD,EAAQ,KAAM,KAAK,IAAI,CAAE,EACtEkC,IACFkB,EAAK,cAAgBlB,GAGnBiB,GACFrC,EAAsB,CAAE,KAAM,sBAAuB,KAAAsC,CAAK,CAAC,CAE/D,EAEaC,EAAwBC,GAAe,CAClD,IAAMtD,EAASuD,EAAmBD,CAAG,EAC/BpB,EAAgB9B,EAA4BkD,CAAG,EAErDd,GAAwBxC,EAAQkC,CAAa,EAE7CpB,EAAsB,CACpB,KAAM,eACN,KAAM,CACJ,OAAAd,EACA,cAAAkC,CACF,CACF,CAAC,CACH,EAEasB,EAAiB3B,GAAsB,CAClDf,EAAsB,CACpB,KAAM,mBACN,KAAM,CACJ,SAAUe,EAAK,UAAY,EAC3B,QAAUA,EAAa,UAAY,CACrC,CACF,CAAC,EACD4B,GAAgB,CAClB,EAEaC,EAA6B,CAACjC,EAAmB6B,IAAe,CAC3E,IAAMK,EAAalC,EAAK,SAAS,SAAS,MAAM,EAC1CH,EAAQG,EAAK,OACbmC,EAAeC,GAAsCpC,EAAK,MAAOkC,EAAYL,EAAKhC,CAAK,EAG7FK,EAAcF,CAAI,EAIlBqC,GAAuB,EAIvBC,GAAqBzC,EAAOsC,CAAY,CAC1C,EAMaI,GAAqC,IAAM,CACtD,GAAM,CAACC,EAAeC,EAAeC,CAAa,EAAIC,GAA6B,EACnFC,GAAcH,EAAeC,CAAa,EAC1CG,GAAWL,CAAa,CAC1B,EAEaM,EAAuB,IAAMrD,GAAe,EAAE,0BAA0B,iCAAiC,EAEzGsD,GAAe,IAC1BtD,GAAe,EAAE,+BAA+B,sCAAsC,EAE3EuD,EAAiCC,GAA2B,CACvE,GAAIC,GAAoBD,CAAO,EAAG,CAChC,IAAMjD,EAAOiD,EAAQ,KACrB,OAAKE,EAAanD,CAAI,GACpBE,EAAcF,CAAI,EAEb+C,GAAa,CACtB,CACF,EAEMK,GAAiC,CACrCH,EACAI,IAC2C,CAC3C,GAAI,CACF,OAAAzB,EAAqByB,CAAS,EAC9BpB,EAA2BgB,EAAQ,KAAqBI,CAAS,EAG1DN,GAAa,CACtB,OAASO,EAAa,CACpBC,GAAwBN,EAASK,CAAW,CAC9C,CACF,EAEMjB,GAAyB,IAAM,CACnC,IAAMmB,EAAcC,GAAe,EAC/BD,GACFzB,EAAcyB,CAAW,CAE7B,EAEMlB,GAAuB,CAACzC,EAAqBsC,IAA6C,CAC9F,QAAW/B,KAAQsD,GAAa7D,CAAK,EAE9BiB,EAAeV,CAAI,GACtBuD,GACEvD,EACAA,EAAK,QAAU,CAAE,GAAGY,EAAgB,EAAG,OAAQxC,EAAO,OAAQ,EAAI2D,CACpE,CAGN,EAEMwB,GAAgC,CAACvD,EAAmB+B,IAA6C,CACrG9C,EAAsB,CACpB,KAAM,uBACN,KAAM,CACJ,GAAGiB,EAAiBF,CAAI,EACxB,GAAG+B,EACH,GAAGyB,GAAgBxD,CAAI,EACvB,OAAQyD,GAAUzD,CAAI,EAAE,IAAK,GAAM,EAAE,EAAE,CACzC,CACF,CAAC,EACDG,EAAmBH,CAAI,CACzB,EAEMgC,GAAwC,CAC5C0B,EACA5B,EACAL,EACAhC,IACG,CACH,IAAMtB,EAAS2D,EAAa1D,EAAO,QAAUsD,EAAmBD,CAAG,EAC7D,CAAE,QAAAzC,EAAS,MAAA2E,CAAM,EAAIpF,EAA4BkD,CAAG,EAC1D,MAAO,CACL,OAAAtD,EACA,cAAe,CACb,QAAS2D,EAAa8B,GAAcF,EAAWjE,CAAK,EAAIT,EACxD,MAAA2E,CACF,CACF,CACF,EAEMC,GAAgB,CAACF,EAAmBjE,IAAwB,CAChE,IAAMoE,EAAYpE,EAAM,MAAQ,IAAIA,EAAM,KAAK,IAAM,OACrD,MAAO,IAAIiE,CAAS,oBAAoBG,CAAS,mBACnD,EAEMC,GAAsB,CAACC,KAAiCjF,IAA2C,CACvG,GAAM,CAACkF,EAAOC,EAAYC,CAAE,EAAIpF,EAChC,OAAI,OAAOoF,EAAO,KAAe,OAAOD,EAAe,IAC9CF,EAAOC,CAAK,EACV,OAAOC,GAAe,WACxBF,EAAOC,EAAOC,CAAU,EAExBF,EAAOC,EAAOC,EAAYC,CAAE,CAEvC,EAEM1B,GAAgB,CAACH,EAA2BC,IAA8B,CAC9E,IAAM6B,EACHJ,GACD,CAACC,EAAOC,EAAYC,IAAO,CACzB7B,EAAc,EACd,GAAI,CACF,OAAOyB,GAAoBC,EAAQC,EAAOC,EAAYC,CAAE,CAC1D,QAAE,CACA5B,EAAc,CAChB,CACF,EACI8B,EAA0C,WAAW,SACrDC,EAAkBF,EAAgBC,CAAkB,EAC1DC,EAAgB,KAAOF,EACrBC,EAAmB,IACrB,EACAC,EAAgB,KAAOF,EAAgBC,EAAmB,IAA4B,EACtF,WAAW,SAAWC,CACxB,EAEM9B,GAA+B,IAA6D,CAChG,IAAI+B,EAAa,EACjB,MAAO,CACL,IAAMA,EACN,IAAM,CACJA,GACF,EACA,IAAM,CACJA,GACF,CACF,CACF,EAEM7B,GAAcL,GAAgC,CAClD,IAAMmC,EAAgB,WAAW,MAC3BC,EAAe,CAACC,EAAuCP,IACpD,OAAOO,GAAa,SACvBF,EAAcE,EAAUC,GAAgBtC,EAAe8B,CAAE,CAAC,EAC1DK,EAAcG,GAAgBtC,EAAeqC,CAAQ,CAAE,EAE7D,WAAW,MAAQD,CACrB,EAEME,GAAkB,CAACtC,EAA6B8B,IAA4D,CAChH,GAAI9B,EAAc,IAAM,GAAK8B,EAAI,CAC/B,IAAMS,EAAYT,EAAG,OAASU,GAAwBV,CAAE,EAAIW,GAAuBX,CAA8B,EACjH,cAAO,eAAeS,EAAW,OAAQ,CAAE,MAAOT,EAAG,IAAK,CAAC,EACpDS,CACT,CACA,OAAOT,CACT,EAEMU,GAA2BV,GACxB,SAA+BY,EAAkB,CACtD,IAAMC,EAAe9B,GAAsB,CACzC,GAAIA,EAAW,CACRD,GAA+B,KAAMC,CAAS,GAAG,KAAK,IAAM6B,EAAK7B,CAAS,CAAC,GAC9E6B,EAAK7B,CAAS,EAEhB,MACF,CAEA,GAAI,CACF,GAAIL,EAA8B,IAAI,GAAG,KAAK,IAAMkC,EAAK,CAAC,EACxD,MAEJ,OAAS5B,EAAa,CACpB4B,EAAK5B,CAAW,EAChB,MACF,CAEA4B,EAAK,CACP,EACA,OAAOZ,EAAG,KAAK,IAAI,EAAEa,CAAW,CAClC,EAGIF,GAA0BX,GACvB,UAA+B,CACpC,IAAIzF,EACAuG,EAEJ,GAAI,CACFvG,EAASyF,EAAG,KAAK,IAAI,EAAE,CACzB,OAASe,EAAG,CACVD,EAAYC,CACd,CAEA,GAAID,EACFE,GAAyB,KAAMF,CAAS,MACnC,QAAIG,EAAU1G,CAAM,EAClBA,EAAO,KACZ,IAAMmE,EAA8B,IAAI,EACvCwC,GAAeF,GAAyB,KAAME,CAAU,CAC3D,GAEAxC,EAA8B,IAAI,EAC3BnE,EAEX,EAGIyG,GAA2B,CAACrC,EAAwBpB,IAAa,CAIrE,GAAI,CAHUuB,GAA+BH,EAASpB,CAAY,GAAG,KAAK,IAAM,CAC9E,MAAMA,CACR,CAAC,EAEC,MAAMA,CAEV,EAEM0B,GAA0B,CAACN,EAAwBpB,IAAiB,CAExE,GAAI,CAEF,QAAQ,MAAM,kDAAkDoB,EAAQ,MAAM,OAAS,aAAa,EAAE,EAEtG,QAAQ,MAAMpB,CAAG,CACnB,MAAQ,CAAC,CACX,EAEMqB,GAAuBD,GAA2B,CACtD,IAAMwC,EAAkBxC,EAAQ,KAIhC,OAHmBA,EAAQ,KAAqB,OACf,MACN,SAAUyC,GAAMA,EAAE,WAAa,WAAW,GAChD,SAAWD,EAAgB,MAClD,EClpBA,GAAM,CACJ,gBAAAE,GACA,kBAAAC,GACA,gBAAAC,GACA,iBAAAC,GACA,eAAAC,GACA,iBAAAC,GACA,gBAAAC,GACA,gBAAAC,GACA,mBAAAC,GACA,eAAAC,EACF,EAAI,MAAM,OAAO,UAEXC,GAAmB,IAAM,CACzBC,GAAoB,IAIxBC,GAAqB,EAGrB,QAAQ,MACL,UAAU,EACV,GAAGZ,GAAiB,IAAM,CACzBa,GAAgB,EAChBC,GAAe,CACjB,CAAC,EACA,GAAGb,GAAoBc,GAAwB,CAC1CA,EAAM,MACRC,GAAc,QAAQ,KAAMD,CAAK,EAEnCE,GAAiBF,CAAK,CACxB,CAAC,EACA,GAAGb,GAAkBa,GAAwB,CAC5CG,GAAeH,CAAK,CACtB,CAAC,EACA,GAAGZ,GAAmBgB,GAAsB,CACvCC,EAAaD,CAAI,GAIrBE,EAAgBF,CAAI,CACtB,CAAC,EACA,GAAGf,GAAiBe,GAAsB,CACrCC,EAAaD,CAAI,GAIrBG,EAAcH,CAAI,CACpB,CAAC,EACA,GAAGd,GAAmBkB,GAAsB,CAGtCC,EAAeD,CAAI,GACtBE,EAAgBF,CAAI,CAExB,CAAC,EACA,GAAGjB,GAAiB,IAAM,CACzBoB,GAAe,CACjB,CAAC,EACA,GAAGnB,GAAiB,CAACoB,EAAuCC,IAAe,CAC1E,IAAMC,EAAS,aAAcF,EAC7B,GAAIE,GAAUC,GAAmBH,CAAU,EAEzC,OAG0BE,GAAUT,EAAaO,CAAU,GAK3DN,EAAgBM,EAAY,KAAK,IAAI,GAAKA,EAAW,UAAY,EAAE,EAIrEI,EAAqBH,CAAG,EAEpBC,GAGFG,EAA2BL,EAAYC,CAAG,CAE9C,CAAC,EACA,GAAGpB,GAAqBe,GAAsB,CAC7CU,GAAeV,CAAI,CACrB,CAAC,EACA,GAAGd,GAAiBc,GAAsB,CACzCW,EAAcX,CAAI,CACpB,CAAC,EAEH,QAAQ,WAAW,SAAS,CAC1B,kBAAmB,CAACY,EAAG,CAAE,KAAAC,EAAM,KAAAC,CAAK,IAAM,CACxCC,GAAiBF,EAAMC,CAAI,CAC7B,CACF,CAAC,EAED,QAAQ,GAAG,OAAST,GAAQ,CAC1B,IAAMW,EAASC,EAAmBZ,CAAG,EAC/Ba,EAAgBC,EAA4Bd,CAAG,EAErD,MAAAe,EAAsBJ,EAAQE,CAAa,EAErCb,CACR,CAAC,EACD,QAAQ,GAAG,gBAAkBgB,GAA4B,CACnDC,EAAuBD,CAAO,GAIlCE,GAAmBF,CAAO,CAC5B,CAAC,EACD,QAAQ,GAAG,cAAgBA,GAA4B,CACjDC,EAAuBD,CAAO,GAIlCG,GAAiB,CACnB,CAAC,EAED,UAAUC,EAA2BC,CAAoB,EAEzD,MAAMD,EAA2B,UAA+B,CAC9DC,EAAqB,EACrBC,EAA8B,IAAI,CACpC,CAAC,EAEDC,GAAmC,EACrC,EAEAzC,GAAiB",
  "names": ["Status", "StatusByPriority", "FAILED", "BROKEN", "PASSED", "SKIPPED", "Stage", "LabelName", "Severity", "ContentType", "LinkType", "getStatusFromError", "error", "test", "constructor", "name", "message", "stack", "Status", "FAILED", "BROKEN", "ansiRegex", "onlyFirst", "arguments", "length", "undefined", "pattern", "join", "RegExp", "stripAnsi", "str", "regex", "replace", "getMessageAndTraceFromError", "trace", "allureIdRegexp", "_wrapRegExp", "id", "allureIdRegexpGlobal", "allureLabelRegexp", "value", "allureLabelRegexpGlobal", "extractMetadataFromString", "title", "labels", "split", "forEach", "val", "_val$match", "idValue", "match", "allureIdRegexp", "groups", "id", "push", "name", "LabelName", "ALLURE_ID", "value", "labelMatch", "allureLabelRegexp", "cleanTitle", "replace", "allureLabelRegexpGlobal", "allureIdRegexpGlobal", "trim", "getStepsMessagesPair", "messages", "reduce", "acc", "message", "type", "push", "unfinishedStepIdx", "findLastIndex", "step", "length", "getUnfinishedStepsMessages", "grouppedStepsMessage", "filter", "isPromise", "obj", "then", "ALLURE_REPORT_SYSTEM_HOOK", "ALLURE_REPORT_STEP_COMMAND", "NoopTestRuntime", "attachment", "_this", "_asyncToGenerator", "warning", "attachmentFromPath", "_this2", "description", "_this3", "descriptionHtml", "_this4", "displayName", "_this5", "historyId", "_this6", "labels", "_this7", "links", "_this8", "parameter", "_this9", "logStep", "_this10", "step", "name", "body", "_this11", "stepDisplayName", "_this12", "stepParameter", "_this13", "testCaseId", "_this14", "console", "log", "noopRuntime", "ALLURE_TEST_RUNTIME_KEY", "setGlobalTestRuntime", "runtime", "globalThis", "getGlobalTestRuntimeFunction", "getGlobalTestRuntime", "testRuntime", "_testRuntime", "noopRuntime", "getGlobalTestRuntimeWithAutoconfig", "_testRuntime2", "eval", "then", "_getGlobalTestRuntime", "_getGlobalTestRuntime2", "err", "console", "log", "callRuntimeMethod", "method", "_len", "arguments", "length", "args", "Array", "_key", "runtime", "getGlobalTestRuntimeWithAutoconfig", "isPromise", "then", "testRuntime", "label", "name", "value", "labels", "_len2", "labelsList", "_key2", "link", "url", "type", "links", "_len3", "linksList", "_key3", "parameter", "options", "description", "markdown", "descriptionHtml", "html", "displayName", "historyId", "testCaseId", "attachment", "content", "opts", "contentType", "attachmentPath", "path", "stepContext", "mode", "logStep", "status", "error", "step", "body", "issue", "LinkType", "ISSUE", "tms", "TMS", "allureId", "LabelName", "ALLURE_ID", "epic", "EPIC", "feature", "FEATURE", "story", "STORY", "suite", "SUITE", "parentSuite", "PARENT_SUITE", "subSuite", "SUB_SUITE", "owner", "OWNER", "severity", "SEVERITY", "layer", "LAYER", "tag", "TAG", "tags", "_len4", "tagsList", "_key4", "map", "getAllureState", "state", "isAllureInitialized", "setAllureInitialized", "getRuntimeMessages", "setRuntimeMessages", "value", "enqueueRuntimeMessage", "message", "getAllureTestPlan", "getCurrentTest", "setCurrentTest", "test", "dropCurrentTest", "uint8ArrayToBase64", "data", "getSuites", "test", "suites", "shouldCommandBeSkipped", "command", "last", "ALLURE_REPORT_STEP_COMMAND", "last", "arr", "getNamesAndLabels", "spec", "test", "rawName", "name", "labels", "extractMetadataFromString", "suites", "fullName", "getTestStartData", "getTestStopData", "getTestSkipData", "applyTestPlan", "root", "testPlan", "getAllureTestPlan", "suite", "iterateSuites", "indicesToRemove", "getIndicesOfDeselectedTests", "removeSortedIndices", "testReportedKey", "markTestAsReported", "test", "isTestReported", "iterateSuites", "parent", "suiteStack", "i", "iterateTests", "suite", "isAllureHook", "hook", "ALLURE_REPORT_SYSTEM_HOOK", "isRootAfterAllHook", "includedInTestPlan", "testPlan", "fullName", "allureId", "getIndicesOfDeselectedTests", "spec", "tests", "indicesToRemove", "index", "labels", "getNamesAndLabels", "name", "LabelName", "removeSortedIndices", "arr", "indices", "AllureCypressTestRuntime", "#resetMessages", "labels", "#enqueueMessageAsync", "links", "name", "value", "options", "markdown", "html", "content", "attachmentRawContent", "actualEncoding", "attachmentContent", "uint8ArrayToBase64", "path", "status", "Status", "error", "ALLURE_REPORT_STEP_COMMAND", "getMessageAndTraceFromError", "body", "result", "mode", "taskName", "messages", "#dequeueAllMessages", "args", "setRuntimeMessages", "message", "enqueueRuntimeMessage", "getRuntimeMessages", "initTestRuntime", "setGlobalTestRuntime", "getTestRuntime", "getGlobalTestRuntime", "reportRunStart", "reportSuiteStart", "suite", "reportSuiteEnd", "reportHookStart", "hook", "start", "reportHookEnd", "reportTestStart", "test", "setCurrentTest", "getTestStartData", "markTestAsReported", "reportUnfinishedSteps", "statusDetails", "runtimeMessages", "getUnfinishedStepsMessages", "reportTestPass", "reportTestSkip", "isTestReported", "reportUnfinishedCommand", "getTestSkipData", "reportCommandStart", "command", "arg", "reportCommandEnd", "reportScreenshot", "ContentType", "startCommandMessageIdx", "type", "stopCommandMessageIdx", "hasUnfinishedCommand", "data", "reportTestOrHookFail", "err", "getStatusFromError", "reportTestEnd", "dropCurrentTest", "completeHookErrorReporting", "isEachHook", "testFailData", "getStatusDataOfTestSkippedByHookError", "reportCurrentTestIfAny", "reportRemainingTests", "enableScopeLevelAfterHookReporting", "getSuiteDepth", "incSuiteDepth", "decSuiteDepth", "createSuiteDepthCounterState", "patchDescribe", "patchAfter", "flushRuntimeMessages", "completeSpec", "completeSpecIfNoAfterHookLeft", "context", "isLastRootAfterHook", "isAllureHook", "completeSpecOnAfterHookFailure", "hookError", "allureError", "logAllureRootAfterError", "currentTest", "getCurrentTest", "iterateTests", "reportTestsSkippedByHookError", "getTestStopData", "getSuites", "hookTitle", "trace", "getSkipReason", "suiteName", "forwardDescribeCall", "target", "title", "configOrFn", "fn", "patchDescribeFn", "originalDescribeFn", "patchedDescribe", "suiteDepth", "originalAfter", "patchedAfter", "nameOrFn", "wrapRootAfterFn", "wrappedFn", "wrapAfterFnWithCallback", "wrapAfterFnWithoutArgs", "done", "wrappedDone", "syncError", "e", "throwAfterSpecCompletion", "isPromise", "asyncError", "currentAfterAll", "h", "EVENT_RUN_BEGIN", "EVENT_SUITE_BEGIN", "EVENT_SUITE_END", "EVENT_HOOK_BEGIN", "EVENT_HOOK_END", "EVENT_TEST_BEGIN", "EVENT_TEST_PASS", "EVENT_TEST_FAIL", "EVENT_TEST_PENDING", "EVENT_TEST_END", "initializeAllure", "isAllureInitialized", "setAllureInitialized", "initTestRuntime", "reportRunStart", "suite", "applyTestPlan", "reportSuiteStart", "reportSuiteEnd", "hook", "isAllureHook", "reportHookStart", "reportHookEnd", "test", "isTestReported", "reportTestStart", "reportTestPass", "testOrHook", "err", "isHook", "isRootAfterAllHook", "reportTestOrHookFail", "completeHookErrorReporting", "reportTestSkip", "reportTestEnd", "_", "path", "name", "reportScreenshot", "status", "getStatusFromError", "statusDetails", "getMessageAndTraceFromError", "reportUnfinishedSteps", "command", "shouldCommandBeSkipped", "reportCommandStart", "reportCommandEnd", "ALLURE_REPORT_SYSTEM_HOOK", "flushRuntimeMessages", "completeSpecIfNoAfterHookLeft", "enableScopeLevelAfterHookReporting"]
}
